/* tslint:disable */
/* eslint-disable */
/**
 * Snapcart API
 * API documentation for the Snapcart Quick e-Commerce platform
 *
 * The version of the OpenAPI document: 1.0
 * Contact: rahilsardar234@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AddItemToCartDto {
    /**
     * Product ID to add to cart
     */
    'productId': string;
    /**
     * Product variant ID to add to cart
     */
    'productVariantId': string;
    /**
     * Quantity to add
     */
    'quantity': number;
}
export interface AddressControllerCreate201Response {
    'message': string;
    'data': AddressResponseDto;
}
export interface AddressControllerDelete200Response {
    'message': string;
    'data': object;
}
export interface AddressControllerFind200Response {
    'message': string;
    'data': Array<AddressResponseDto>;
}
export interface AddressResponseDto {
    'id': string;
    'customerId': string;
    'isPrimary': boolean;
    'houseNo'?: string;
    'street'?: string;
    'city'?: string;
    'state'?: string;
    'country'?: string;
    'pincode'?: string;
    'createdAt': string;
    'updatedAt': string;
}
export interface AdminCouponControllerGetUsageHistory200Response {
    'message': string;
    'data': Array<CouponUsageResponseDto>;
}
export interface AdminProductControllerGetAdminProducts200Response {
    'message': string;
    'data': Array<ProductResponseDto>;
    /**
     * Pagination metadata
     */
    'meta': PaginationMetaDto;
}
export interface AppliedOfferDto {
    /**
     * Offer ID
     */
    'id': string;
    /**
     * Offer name
     */
    'name': string;
    /**
     * Discount amount applied
     */
    'discount': number;
}
export interface ApplyCouponDto {
    /**
     * Coupon code to apply
     */
    'code': string;
}
export interface BadRequestErrorDto {
    'statusCode': number;
    /**
     * List of validation errors
     */
    'message': Array<string>;
    'error': string;
}
export interface CancelOrderDto {
    /**
     * Reason for cancelling the order
     */
    'cancelReason': string;
}
export interface CartControllerAddItem201Response {
    'message': string;
    'data': CartItemResponseDto;
}
export interface CartControllerGetCart200Response {
    'message': string;
    'data': CartWithDetailsResponseDto;
}
export interface CartControllerGetCartPricing200Response {
    'message': string;
    'data': CartPricingDto;
}
export interface CartItemResponseDto {
    /**
     * Cart item ID
     */
    'id': string;
    /**
     * Cart ID
     */
    'cartId': string;
    /**
     * Product variant ID
     */
    'productId': string;
    /**
     * Product variant ID
     */
    'variantId': string;
    /**
     * Quantity of the item
     */
    'quantity': number;
    /**
     * Created at timestamp
     */
    'createdAt': string;
    /**
     * Updated at timestamp
     */
    'updatedAt': string;
}
export interface CartItemWithDetailsResponseDto {
    /**
     * Cart item ID
     */
    'id': string;
    /**
     * Cart ID
     */
    'cartId': string;
    /**
     * Product variant ID
     */
    'productVariantId': string;
    /**
     * Quantity of the item
     */
    'quantity': number;
    /**
     * Product variant details
     */
    'variant': ProductVariantDetailDto;
    /**
     * Subtotal (quantity Ã— final price)
     */
    'subtotal': number;
    /**
     * Created at timestamp
     */
    'createdAt': string;
    /**
     * Updated at timestamp
     */
    'updatedAt': string;
}
export interface CartPricingDto {
    /**
     * Subtotal before any discounts
     */
    'subtotal': number;
    /**
     * Total discount from offers
     */
    'offerDiscount': number;
    /**
     * Discount from applied coupon
     */
    'couponDiscount': number;
    /**
     * Total discount amount
     */
    'totalDiscount': number;
    /**
     * Final total after all discounts
     */
    'finalTotal': number;
    /**
     * IDs of applied offers
     */
    'appliedOfferIds': Array<string>;
    /**
     * Applied coupon code
     */
    'appliedCouponCode'?: string;
    /**
     * Total savings from all discounts
     */
    'savings': number;
    /**
     * List of applied offers with details
     */
    'appliedOffers': Array<AppliedOfferDto>;
}
export interface CartWithDetailsResponseDto {
    /**
     * Cart ID
     */
    'id': string;
    /**
     * Customer ID
     */
    'customerId': string;
    /**
     * Cart items with full product details
     */
    'items': Array<CartItemWithDetailsResponseDto>;
    /**
     * Total number of items (sum of all quantities)
     */
    'totalItems': number;
    /**
     * Number of unique items
     */
    'uniqueItemsCount': number;
    /**
     * Total amount (sum of all subtotals)
     */
    'totalAmount': number;
    /**
     * Whether the cart is empty
     */
    'isEmpty': boolean;
    /**
     * Created at timestamp
     */
    'createdAt': string;
    /**
     * Updated at timestamp
     */
    'updatedAt': string;
}
export interface CategoryControllerFindAll200Response {
    'message': string;
    'data': Array<CategoryResponseDto>;
}
export interface CategoryControllerFindOne200Response {
    'message': string;
    'data': CategoryResponseDto;
}
export interface CategoryNestedDto {
    /**
     * Category ID
     */
    'id': string;
    /**
     * Category name
     */
    'name': string;
    /**
     * Category status
     */
    'status': CategoryNestedDtoStatusEnum;
}

export const CategoryNestedDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive'
} as const;

export type CategoryNestedDtoStatusEnum = typeof CategoryNestedDtoStatusEnum[keyof typeof CategoryNestedDtoStatusEnum];

export interface CategoryResponseDto {
    /**
     * Category ID
     */
    'id': string;
    /**
     * Category name
     */
    'name': string;
    /**
     * Category status
     */
    'status': CategoryResponseDtoStatusEnum;
    /**
     * Creation timestamp
     */
    'createdAt': string;
    /**
     * Last update timestamp
     */
    'updatedAt': string;
}

export const CategoryResponseDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive'
} as const;

export type CategoryResponseDtoStatusEnum = typeof CategoryResponseDtoStatusEnum[keyof typeof CategoryResponseDtoStatusEnum];

export interface CheckoutCommitDto {
    /**
     * Checkout source - where checkout is initiated from
     */
    'source': CheckoutCommitDtoSourceEnum;
    /**
     * Coupon code to apply
     */
    'couponCode'?: string;
    /**
     * Shipping address ID
     */
    'shippingAddressId': string;
    /**
     * Payment method
     */
    'paymentMethod': string;
}

export const CheckoutCommitDtoSourceEnum = {
    Product: 'PRODUCT',
    Cart: 'CART'
} as const;

export type CheckoutCommitDtoSourceEnum = typeof CheckoutCommitDtoSourceEnum[keyof typeof CheckoutCommitDtoSourceEnum];

export interface CheckoutCommitResponseDto {
    /**
     * Order ID
     */
    'id': string;
    /**
     * Order number
     */
    'orderNumber': string;
    /**
     * Subtotal before any discounts
     */
    'subtotal': number;
    /**
     * Product-level discount
     */
    'discount': number;
    /**
     * Coupon discount applied
     */
    'couponDiscount': number;
    /**
     * Offer discount applied
     */
    'offerDiscount': number;
    /**
     * Shipping charge
     */
    'shippingCharge': number;
    /**
     * Tax amount
     */
    'tax': number;
    /**
     * Final total amount
     */
    'total': number;
    /**
     * Applied coupon code
     */
    'appliedCouponCode'?: object;
    /**
     * Order items
     */
    'items': Array<object>;
    /**
     * Payment status
     */
    'paymentStatus': string;
    /**
     * Order status
     */
    'orderStatus': string;
}
export interface CheckoutControllerCommitCheckout201Response {
    'message': string;
    'data': CheckoutCommitResponseDto;
}
export interface CheckoutControllerPreviewCheckout200Response {
    'message': string;
    'data': CheckoutPreviewResponseDto;
}
export interface CheckoutPreviewDto {
    /**
     * Checkout source - where checkout is initiated from
     */
    'source': CheckoutPreviewDtoSourceEnum;
    /**
     * Coupon code to apply
     */
    'couponCode'?: string;
}

export const CheckoutPreviewDtoSourceEnum = {
    Product: 'PRODUCT',
    Cart: 'CART'
} as const;

export type CheckoutPreviewDtoSourceEnum = typeof CheckoutPreviewDtoSourceEnum[keyof typeof CheckoutPreviewDtoSourceEnum];

export interface CheckoutPreviewResponseDto {
    /**
     * Subtotal before any discounts
     */
    'subtotal': number;
    /**
     * Product-level discount
     */
    'productDiscount': number;
    /**
     * Coupon discount applied
     */
    'couponDiscount': number;
    /**
     * Offer discount applied
     */
    'offerDiscount': number;
    /**
     * Shipping charge
     */
    'shippingCharge': number;
    /**
     * Tax amount
     */
    'tax': number;
    /**
     * Final total amount
     */
    'total': number;
    /**
     * Applied coupon details
     */
    'couponSnapshot'?: CouponSnapshotDto;
}
export interface ConflictErrorDto {
    'statusCode': number;
    'message': string;
    'error': string;
}
export interface CouponControllerGetAvailableCoupons200Response {
    'message': string;
    'data': Array<CouponResponseDto>;
}
export interface CouponControllerGetCouponByCode200Response {
    'message': string;
    'data': CouponResponseDto;
}
export interface CouponControllerValidateCoupon200Response {
    'message': string;
    'data': CouponValidationResponseDto;
}
export interface CouponResponseDto {
    /**
     * Coupon ID
     */
    'id': string;
    /**
     * Coupon code
     */
    'code': string;
    /**
     * Discount type
     */
    'type': CouponResponseDtoTypeEnum;
    /**
     * Discount value
     */
    'discount': number;
    /**
     * Minimum cart amount required
     */
    'minAmount': number;
    /**
     * Maximum discount amount
     */
    'maxDiscount'?: number;
    /**
     * Coupon start date
     */
    'startDate': string;
    /**
     * Coupon end date
     */
    'endDate': string;
    /**
     * Coupon status
     */
    'status': CouponResponseDtoStatusEnum;
    /**
     * Total usage limit
     */
    'usageLimit'?: number;
    /**
     * Times this coupon has been used
     */
    'usedCount': number;
    /**
     * Maximum times a user can use this coupon
     */
    'maxUsagePerUser': number;
    /**
     * Applicability scope
     */
    'applicableTo': CouponResponseDtoApplicableToEnum;
    /**
     * Can be stacked with offers
     */
    'isStackable': boolean;
    /**
     * Coupon description
     */
    'description'?: string;
    /**
     * Whether coupon is currently active
     */
    'isActive': boolean;
    /**
     * Whether usage limit is reached
     */
    'isLimitReached': boolean;
    /**
     * Creation timestamp
     */
    'createdAt': string;
    /**
     * Last update timestamp
     */
    'updatedAt': string;
}

export const CouponResponseDtoTypeEnum = {
    Percentage: 'Percentage',
    Flat: 'Flat'
} as const;

export type CouponResponseDtoTypeEnum = typeof CouponResponseDtoTypeEnum[keyof typeof CouponResponseDtoTypeEnum];
export const CouponResponseDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Expired: 'expired'
} as const;

export type CouponResponseDtoStatusEnum = typeof CouponResponseDtoStatusEnum[keyof typeof CouponResponseDtoStatusEnum];
export const CouponResponseDtoApplicableToEnum = {
    All: 'all',
    SpecificProducts: 'specific_products',
    SpecificCategories: 'specific_categories'
} as const;

export type CouponResponseDtoApplicableToEnum = typeof CouponResponseDtoApplicableToEnum[keyof typeof CouponResponseDtoApplicableToEnum];

export interface CouponSnapshotDto {
    /**
     * Coupon code
     */
    'code': string;
    /**
     * Coupon type
     */
    'type': string;
    /**
     * Discount value
     */
    'discount': number;
    /**
     * Discount applied
     */
    'discountApplied': number;
}
export interface CouponUsageResponseDto {
    /**
     * Usage record ID
     */
    'id': string;
    /**
     * Coupon ID
     */
    'couponId': string;
    /**
     * User ID who used the coupon
     */
    'userId': string;
    /**
     * Order ID where coupon was applied
     */
    'orderId'?: string;
    /**
     * Discount amount that was applied
     */
    'discountApplied': number;
    /**
     * When the coupon was used
     */
    'usedAt': string;
}
export interface CouponValidationResponseDto {
    /**
     * Whether the coupon is valid
     */
    'valid': boolean;
    /**
     * Reason if coupon is invalid
     */
    'reason': string | null;
    /**
     * Discount amount that will be applied
     */
    'discount': number;
    /**
     * Coupon code that was validated
     */
    'code': string;
}
export interface CreateAddressDto {
    /**
     * House number
     */
    'houseNo'?: string;
    /**
     * Street
     */
    'street'?: string;
    /**
     * City
     */
    'city'?: string;
    /**
     * State
     */
    'state'?: string;
    /**
     * Country
     */
    'country'?: string;
    /**
     * Pincode
     */
    'pincode'?: string;
    /**
     * Is primary address
     */
    'isPrimary'?: boolean;
}
export interface CreateCategoryDto {
    /**
     * Category name
     */
    'name': string;
    /**
     * Category description
     */
    'description'?: object;
    /**
     * Category image URL
     */
    'imageUrl'?: object;
    /**
     * Parent category ID for subcategories
     */
    'parentId'?: object;
}
export interface CreateCouponDto {
    /**
     * Unique coupon code (will be converted to uppercase)
     */
    'code': string;
    /**
     * Type of discount
     */
    'type': CreateCouponDtoTypeEnum;
    /**
     * Discount value (percentage or flat amount)
     */
    'discount': number;
    /**
     * Minimum cart amount required to use coupon
     */
    'minAmount': number;
    /**
     * Coupon start date
     */
    'startDate': string;
    /**
     * Coupon end date
     */
    'endDate': string;
    /**
     * Maximum discount amount (for percentage coupons)
     */
    'maxDiscount'?: number;
    /**
     * Total usage limit for this coupon
     */
    'usageLimit'?: number;
    /**
     * Maximum times a single user can use this coupon
     */
    'maxUsagePerUser': number;
    /**
     * Applicability scope
     */
    'applicableTo': CreateCouponDtoApplicableToEnum;
    /**
     * Whether coupon can be combined with offers
     */
    'isStackable': boolean;
    /**
     * Coupon description for users
     */
    'description'?: string;
}

export const CreateCouponDtoTypeEnum = {
    Percentage: 'Percentage',
    Flat: 'Flat'
} as const;

export type CreateCouponDtoTypeEnum = typeof CreateCouponDtoTypeEnum[keyof typeof CreateCouponDtoTypeEnum];
export const CreateCouponDtoApplicableToEnum = {
    All: 'all',
    SpecificProducts: 'specific_products',
    SpecificCategories: 'specific_categories'
} as const;

export type CreateCouponDtoApplicableToEnum = typeof CreateCouponDtoApplicableToEnum[keyof typeof CreateCouponDtoApplicableToEnum];

export interface CreateOfferDto {
    /**
     * Offer name
     */
    'name': string;
    /**
     * Type of discount
     */
    'type': CreateOfferDtoTypeEnum;
    /**
     * Discount value (percentage or flat amount)
     */
    'discount': number;
    /**
     * Offer start date
     */
    'startDate': string;
    /**
     * Offer end date
     */
    'endDate': string;
    /**
     * Minimum purchase amount required
     */
    'minPurchaseAmount': number;
    /**
     * Maximum discount amount (for percentage offers)
     */
    'maxDiscount'?: number;
    /**
     * Priority (higher number = higher priority)
     */
    'priority': number;
    /**
     * Category IDs this offer applies to
     */
    'categories'?: Array<string>;
    /**
     * Product IDs this offer applies to
     */
    'products'?: Array<string>;
    /**
     * Whether offer can be combined with coupons
     */
    'isStackable': boolean;
    /**
     * Offer description for users
     */
    'description'?: string;
}

export const CreateOfferDtoTypeEnum = {
    Percentage: 'Percentage',
    Flat: 'Flat'
} as const;

export type CreateOfferDtoTypeEnum = typeof CreateOfferDtoTypeEnum[keyof typeof CreateOfferDtoTypeEnum];

export interface CreateProductDto {
    /**
     * Product name (catalog identity)
     */
    'name': string;
    /**
     * Product description
     */
    'description': string;
    /**
     * Category ID
     */
    'categoryId': string;
    /**
     * Brand name
     */
    'brand'?: string;
}
export interface CreateVariantDto {
    /**
     * Variant name (e.g., size, weight, color)
     */
    'variantName': string;
    /**
     * Price (base price before discount)
     */
    'price': number;
    /**
     * Stock quantity
     */
    'stock': number;
    /**
     * Discount percentage (0-100)
     */
    'discountPercent'?: number;
    /**
     * Seller profile ID (who sells this variant)
     */
    'sellerProfileId'?: string;
    /**
     * Additional attributes (e.g., weight, organic flag)
     */
    'attributes'?: object;
}
export interface CustomerInfoResponseDto {
    /**
     * Customer profile ID
     */
    'customerId': string;
    /**
     * Customer name
     */
    'customerName'?: string | null;
    /**
     * Customer email
     */
    'customerEmail'?: string | null;
    /**
     * Customer phone
     */
    'customerPhone'?: string | null;
}
export interface CustomerOrderControllerCancelOrder200Response {
    'message': string;
    'data': OrderResponseDto;
}
export interface CustomerOrderControllerGetMyOrders200Response {
    'message': string;
    'data': Array<OrderResponseDto>;
}
export interface CustomerProfileDto {
    'id': string;
    'name'?: string;
}
export interface FeedControllerGetFeed200Response {
    'message': string;
    'data': Array<GetCategoryProductFeedResponseDto>;
}
export interface ForbiddenErrorDto {
    'statusCode': number;
    'message': string;
    'error': string;
}
export interface GetCategoryProductFeedResponseDto {
    /**
     * The unique identifier of the category
     */
    'id': string;
    /**
     * The name of the category
     */
    'name': string;
    /**
     * List of products in the category
     */
    'products': Array<ProductDto>;
}
export interface HttpPaginatedResponse {
    'message': string;
    'data'?: object;
    /**
     * Pagination metadata
     */
    'meta': PaginationMetaDto;
}
export interface HttpResponse {
    'message': string;
    'data'?: object;
}
export interface InternalServerErrorDto {
    'statusCode': number;
    'message': string;
    'error': string;
}
export interface LoginDto {
    /**
     * Email or phone number
     */
    'identifier': string;
    /**
     * Authentication method (PASSWORD or OTP only)
     */
    'method': LoginDtoMethodEnum;
    /**
     * Password (required for PASSWORD method)
     */
    'password'?: string;
    /**
     * OTP code (required for OTP method)
     */
    'otp'?: string;
}

export const LoginDtoMethodEnum = {
    Password: 'PASSWORD',
    Otp: 'OTP'
} as const;

export type LoginDtoMethodEnum = typeof LoginDtoMethodEnum[keyof typeof LoginDtoMethodEnum];

export interface LoginWithGoogleDto {
    /**
     * Google ID token
     */
    'idToken': string;
}
export interface MeResponseDto {
    'id': string;
    'email'?: string;
    'role': MeResponseDtoRoleEnum;
    'status': MeResponseDtoStatusEnum;
    'customerProfile'?: CustomerProfileDto;
    'sellerProfile'?: SellerProfileDto;
}

export const MeResponseDtoRoleEnum = {
    Admin: 'ADMIN',
    Seller: 'SELLER',
    Customer: 'CUSTOMER'
} as const;

export type MeResponseDtoRoleEnum = typeof MeResponseDtoRoleEnum[keyof typeof MeResponseDtoRoleEnum];
export const MeResponseDtoStatusEnum = {
    Active: 'active',
    Suspended: 'suspended',
    Disabled: 'disabled'
} as const;

export type MeResponseDtoStatusEnum = typeof MeResponseDtoStatusEnum[keyof typeof MeResponseDtoStatusEnum];

export interface MessageOnlyResponse {
    'message': string;
}
export interface NotFoundErrorDto {
    'statusCode': number;
    'message': string;
    'error': string;
}
export interface OfferControllerGetActiveOffers200Response {
    'message': string;
    'data': Array<OfferResponseDto>;
}
export interface OfferControllerGetOffer200Response {
    'message': string;
    'data': OfferResponseDto;
}
export interface OfferResponseDto {
    /**
     * Offer ID
     */
    'id': string;
    /**
     * Offer name
     */
    'name': string;
    /**
     * Discount type
     */
    'type': OfferResponseDtoTypeEnum;
    /**
     * Discount value
     */
    'discount': number;
    /**
     * Minimum purchase amount required
     */
    'minPurchaseAmount': number;
    /**
     * Maximum discount amount
     */
    'maxDiscount'?: number;
    /**
     * Priority (higher = more important)
     */
    'priority': number;
    /**
     * Offer start date
     */
    'startDate': string;
    /**
     * Offer end date
     */
    'endDate': string;
    /**
     * Offer status
     */
    'status': OfferResponseDtoStatusEnum;
    /**
     * Can be stacked with coupons
     */
    'isStackable': boolean;
    /**
     * Applicable category IDs
     */
    'categories': Array<string>;
    /**
     * Applicable product IDs
     */
    'products': Array<string>;
    /**
     * Offer description
     */
    'description'?: string;
    /**
     * Whether offer is currently active
     */
    'isActive': boolean;
    /**
     * Creation timestamp
     */
    'createdAt': string;
    /**
     * Last update timestamp
     */
    'updatedAt': string;
}

export const OfferResponseDtoTypeEnum = {
    Percentage: 'Percentage',
    Flat: 'Flat'
} as const;

export type OfferResponseDtoTypeEnum = typeof OfferResponseDtoTypeEnum[keyof typeof OfferResponseDtoTypeEnum];
export const OfferResponseDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Expired: 'expired'
} as const;

export type OfferResponseDtoStatusEnum = typeof OfferResponseDtoStatusEnum[keyof typeof OfferResponseDtoStatusEnum];

export interface OrderItemResponseDto {
    /**
     * Product ID
     */
    'productId': string;
    /**
     * Product name
     */
    'productName': string;
    /**
     * Variant ID
     */
    'variantId': string;
    /**
     * Variant name
     */
    'variantName': string;
    /**
     * Quantity ordered
     */
    'quantity': number;
    /**
     * Base price per item
     */
    'basePrice': number;
    /**
     * Discount percentage applied
     */
    'discountPercent': number;
    /**
     * Final price per item after discount
     */
    'finalPrice': number;
    /**
     * Total price for this item
     */
    'totalPrice': number;
    /**
     * Product variant attributes
     */
    'attributes': object;
    /**
     * Product image URL
     */
    'imageUrl': string | null;
}
export interface OrderResponseDto {
    /**
     * Order ID
     */
    'id': string;
    /**
     * Order number
     */
    'orderNumber': string;
    /**
     * Customer ID
     */
    'customerId': string;
    /**
     * Customer information
     */
    'customer'?: CustomerInfoResponseDto;
    /**
     * Order items
     */
    'items': Array<OrderItemResponseDto>;
    /**
     * Subtotal amount
     */
    'subtotal': number;
    /**
     * Discount amount
     */
    'discount': number;
    /**
     * Coupon discount amount
     */
    'couponDiscount': number;
    /**
     * Offer discount amount
     */
    'offerDiscount': number;
    /**
     * Shipping charge
     */
    'shippingCharge': number;
    /**
     * Tax amount
     */
    'tax': number;
    /**
     * Total amount
     */
    'total': number;
    /**
     * Applied coupon code
     */
    'appliedCouponCode': string | null;
    /**
     * Applied offer IDs
     */
    'appliedOfferIds': Array<string>;
    /**
     * Shipping address JSON
     */
    'shippingAddress': object;
    /**
     * Payment method
     */
    'paymentMethod': string | null;
    /**
     * Payment status
     */
    'paymentStatus': OrderResponseDtoPaymentStatusEnum;
    /**
     * Order status
     */
    'orderStatus': OrderResponseDtoOrderStatusEnum;
    /**
     * Order metadata
     */
    'metadata': object;
    /**
     * Cancel reason
     */
    'cancelReason': string | null;
    /**
     * Refund amount
     */
    'refundAmount': number | null;
    /**
     * Order placed date
     */
    'placedAt': string;
    /**
     * Delivered date
     */
    'deliveredAt': string | null;
    /**
     * Cancelled date
     */
    'cancelledAt': string | null;
    /**
     * Last updated date
     */
    'updatedAt': string;
}

export const OrderResponseDtoPaymentStatusEnum = {
    Pending: 'pending',
    Paid: 'paid',
    Failed: 'failed',
    Refunded: 'refunded'
} as const;

export type OrderResponseDtoPaymentStatusEnum = typeof OrderResponseDtoPaymentStatusEnum[keyof typeof OrderResponseDtoPaymentStatusEnum];
export const OrderResponseDtoOrderStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Shipping: 'shipping',
    Delivered: 'delivered',
    Canceled: 'canceled',
    ReturnRequested: 'return_requested',
    ReturnApproved: 'return_approved',
    ReturnRejected: 'return_rejected',
    Returned: 'returned'
} as const;

export type OrderResponseDtoOrderStatusEnum = typeof OrderResponseDtoOrderStatusEnum[keyof typeof OrderResponseDtoOrderStatusEnum];

export interface PaginationMetaDto {
    /**
     * Current page number
     */
    'page': number;
    /**
     * Number of items per page
     */
    'limit': number;
    /**
     * Total number of items
     */
    'total': number;
    /**
     * Whether there is a next page
     */
    'hasNextPage': boolean;
    /**
     * Whether there is a previous page
     */
    'hasPrevPage': boolean;
}
export interface ProductControllerUpdate200Response {
    'message': string;
    'data': ProductResponseDto;
}
export interface ProductDetailDto {
    /**
     * Product ID
     */
    'id': string;
    /**
     * Product name
     */
    'name': string;
    /**
     * Product description
     */
    'description': string;
    /**
     * Brand name
     */
    'brand'?: string;
    /**
     * Product status (catalog lifecycle)
     */
    'status': ProductDetailDtoStatusEnum;
    /**
     * Whether product is active in catalog
     */
    'isActive': boolean;
    /**
     * Category details
     */
    'category': CategoryNestedDto;
    /**
     * All available variants with images
     */
    'variants': Array<VariantResponseDto>;
    /**
     * Product creation date
     */
    'createdAt': string;
    /**
     * Product last update date
     */
    'updatedAt': string;
}

export const ProductDetailDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Discontinued: 'discontinued'
} as const;

export type ProductDetailDtoStatusEnum = typeof ProductDetailDtoStatusEnum[keyof typeof ProductDetailDtoStatusEnum];

export interface ProductDto {
    /**
     * The unique identifier of the product
     */
    'id': string;
    /**
     * The name of the product
     */
    'name': string;
    /**
     * The category of the product
     */
    'category': CategoryResponseDto;
    /**
     * The variant of the product
     */
    'variant': ProductVariantDto;
}
export interface ProductPublicControllerFindAll200Response {
    'message': string;
    'data': Array<ProductWithVariantPreviewDto>;
    /**
     * Pagination metadata
     */
    'meta': PaginationMetaDto;
}
export interface ProductPublicControllerFindOne200Response {
    'message': string;
    'data': ProductWithVariantsResponseDto;
}
export interface ProductPublicControllerGetProductWithVariants200Response {
    'message': string;
    'data': ProductDetailDto;
}
export interface ProductResponseDto {
    /**
     * Product ID
     */
    'id': string;
    /**
     * Product name
     */
    'name': string;
    /**
     * Product description
     */
    'description': string;
    /**
     * Category ID
     */
    'categoryId': string;
    /**
     * Brand name
     */
    'brand'?: string;
    /**
     * Product status (catalog lifecycle)
     */
    'status': ProductResponseDtoStatusEnum;
    /**
     * Whether product is active in catalog
     */
    'isActive': boolean;
    /**
     * Whether product is in catalog (not deleted/discontinued)
     */
    'isInCatalog': boolean;
    /**
     * Product creation date
     */
    'createdAt': string;
    /**
     * Product last update date
     */
    'updatedAt': string;
}

export const ProductResponseDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Discontinued: 'discontinued'
} as const;

export type ProductResponseDtoStatusEnum = typeof ProductResponseDtoStatusEnum[keyof typeof ProductResponseDtoStatusEnum];

export interface ProductVariantDetailDto {
    /**
     * Product variant ID
     */
    'id': string;
    /**
     * Variant name (e.g., \"500g\", \"1kg\", \"Red-M\")
     */
    'variantName': string;
    /**
     * Price of the variant
     */
    'price': number;
    /**
     * Discount percentage
     */
    'discountPercent': number;
    /**
     * Final price after discount
     */
    'finalPrice': number;
    /**
     * Stock available
     */
    'stock': number;
    /**
     * Variant status
     */
    'status': string;
    /**
     * Product ID
     */
    'productId': string;
    /**
     * Product name
     */
    'productName': string;
    /**
     * Product description
     */
    'productDescription': string;
    /**
     * Product brand
     */
    'productBrand': object | null;
    /**
     * Variant image URL
     */
    'imageUrl': string;
}
export interface ProductVariantDto {
    /**
     * The unique identifier of the product variant
     */
    'id': string;
    /**
     * The name of the product variant
     */
    'variantName': string;
    /**
     * The price of the product variant
     */
    'price': number;
    /**
     * The discount percentage of the product variant
     */
    'discountPercentage'?: number;
    /**
     * The URL of the product variant image
     */
    'imageUrl': string;
}
export interface ProductWithVariantPreviewDto {
    /**
     * Product ID
     */
    'id': string;
    /**
     * Product name
     */
    'name': string;
    /**
     * Brand name
     */
    'brand'?: string;
    /**
     * Category details
     */
    'category': CategoryNestedDto;
    /**
     * Featured/first variant for quick preview
     */
    'variant': VariantPreviewDto;
}
export interface ProductWithVariantsResponseDto {
    /**
     * Product ID
     */
    'id': string;
    /**
     * Product name
     */
    'name': string;
    /**
     * Product description
     */
    'description': string;
    /**
     * Category ID
     */
    'categoryId': string;
    /**
     * Brand name
     */
    'brand'?: string;
    /**
     * Product status (catalog lifecycle)
     */
    'status': ProductWithVariantsResponseDtoStatusEnum;
    /**
     * Whether product is active in catalog
     */
    'isActive': boolean;
    /**
     * Whether product is in catalog (not deleted/discontinued)
     */
    'isInCatalog': boolean;
    /**
     * Product creation date
     */
    'createdAt': string;
    /**
     * Product last update date
     */
    'updatedAt': string;
    /**
     * Category details
     */
    'category': CategoryNestedDto;
    /**
     * Sellable variants of the product
     */
    'variants': Array<VariantResponseDto>;
}

export const ProductWithVariantsResponseDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Discontinued: 'discontinued'
} as const;

export type ProductWithVariantsResponseDtoStatusEnum = typeof ProductWithVariantsResponseDtoStatusEnum[keyof typeof ProductWithVariantsResponseDtoStatusEnum];

export interface RegisterDto {
    /**
     * Email address
     */
    'email'?: string;
    /**
     * Phone number
     */
    'phone'?: string;
    /**
     * Password (min 6 characters)
     */
    'password': string;
}
export interface RequestOTPDto {
    /**
     * Email or phone number
     */
    'identifier': string;
}
export interface SaveVariantImageDto {
    /**
     * Cloudinary public ID returned after upload
     */
    'publicId': string;
    /**
     * Image URL returned from Cloudinary
     */
    'url': string;
}
export interface SellerProductControllerGetSellerProducts200Response {
    'message': string;
    'data': Array<ProductWithVariantsResponseDto>;
    /**
     * Pagination metadata
     */
    'meta': PaginationMetaDto;
}
export interface SellerProfileDto {
    'id': string;
    'storeName': string;
    'isVerified': boolean;
}
export interface UnauthorizedErrorDto {
    'statusCode': number;
    'message': string;
    'error': string;
}
export interface UpdateAddressDto {
    /**
     * House number (set to null to clear)
     */
    'houseNo'?: string;
    /**
     * Street (set to null to clear)
     */
    'street'?: string;
    /**
     * City (set to null to clear)
     */
    'city'?: string;
    /**
     * State (set to null to clear)
     */
    'state'?: string;
    /**
     * Country (set to null to clear)
     */
    'country'?: string;
    /**
     * Pincode (set to null to clear)
     */
    'pincode'?: string;
    /**
     * Is primary address
     */
    'isPrimary'?: boolean;
}
export interface UpdateCartItemDto {
    /**
     * New quantity for the cart item
     */
    'quantity': number;
}
export interface UpdateCategoryDto {
    /**
     * Category name
     */
    'name'?: string;
    /**
     * Category status (e.g., active, inactive)
     */
    'status'?: UpdateCategoryDtoStatusEnum;
    /**
     * Category image URL
     */
    'imageUrl'?: object;
    /**
     * Parent category ID for subcategories
     */
    'parentId'?: object;
}

export const UpdateCategoryDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive'
} as const;

export type UpdateCategoryDtoStatusEnum = typeof UpdateCategoryDtoStatusEnum[keyof typeof UpdateCategoryDtoStatusEnum];

export interface UpdateCouponDto {
    /**
     * Unique coupon code
     */
    'code'?: string;
    /**
     * Type of discount
     */
    'type'?: UpdateCouponDtoTypeEnum;
    /**
     * Discount value
     */
    'discount'?: number;
    /**
     * Minimum cart amount
     */
    'minAmount'?: number;
    /**
     * Maximum discount amount
     */
    'maxDiscount'?: number;
    /**
     * Start date
     */
    'startDate'?: string;
    /**
     * End date
     */
    'endDate'?: string;
    /**
     * Total usage limit
     */
    'usageLimit'?: number;
    /**
     * Max usage per user
     */
    'maxUsagePerUser'?: number;
    /**
     * Applicability scope
     */
    'applicableTo'?: UpdateCouponDtoApplicableToEnum;
    /**
     * Stackable with offers
     */
    'isStackable'?: boolean;
    /**
     * Coupon description
     */
    'description'?: string;
}

export const UpdateCouponDtoTypeEnum = {
    Percentage: 'Percentage',
    Flat: 'Flat'
} as const;

export type UpdateCouponDtoTypeEnum = typeof UpdateCouponDtoTypeEnum[keyof typeof UpdateCouponDtoTypeEnum];
export const UpdateCouponDtoApplicableToEnum = {
    All: 'all',
    SpecificProducts: 'specific_products',
    SpecificCategories: 'specific_categories'
} as const;

export type UpdateCouponDtoApplicableToEnum = typeof UpdateCouponDtoApplicableToEnum[keyof typeof UpdateCouponDtoApplicableToEnum];

export interface UpdateOfferDto {
    /**
     * Offer name
     */
    'name'?: string;
    /**
     * Type of discount
     */
    'type'?: UpdateOfferDtoTypeEnum;
    /**
     * Discount value
     */
    'discount'?: number;
    /**
     * Start date
     */
    'startDate'?: string;
    /**
     * End date
     */
    'endDate'?: string;
    /**
     * Minimum purchase amount
     */
    'minPurchaseAmount'?: number;
    /**
     * Maximum discount amount
     */
    'maxDiscount'?: number;
    /**
     * Priority
     */
    'priority'?: number;
    /**
     * Category IDs
     */
    'categories'?: Array<string>;
    /**
     * Product IDs
     */
    'products'?: Array<string>;
    /**
     * Stackable with coupons
     */
    'isStackable'?: boolean;
    /**
     * Offer description
     */
    'description'?: string;
}

export const UpdateOfferDtoTypeEnum = {
    Percentage: 'Percentage',
    Flat: 'Flat'
} as const;

export type UpdateOfferDtoTypeEnum = typeof UpdateOfferDtoTypeEnum[keyof typeof UpdateOfferDtoTypeEnum];

export interface UpdateOrderStatusDto {
    /**
     * New order status
     */
    'status': UpdateOrderStatusDtoStatusEnum;
}

export const UpdateOrderStatusDtoStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Shipping: 'shipping',
    Delivered: 'delivered',
    Canceled: 'canceled',
    ReturnRequested: 'return_requested',
    ReturnApproved: 'return_approved',
    ReturnRejected: 'return_rejected',
    Returned: 'returned'
} as const;

export type UpdateOrderStatusDtoStatusEnum = typeof UpdateOrderStatusDtoStatusEnum[keyof typeof UpdateOrderStatusDtoStatusEnum];

export interface UpdateProductDto {
    /**
     * Product name
     */
    'name'?: string;
    /**
     * Product description
     */
    'description'?: string;
    /**
     * Brand name
     */
    'brand'?: string;
    /**
     * Category ID (use with caution - cannot change if discontinued)
     */
    'categoryId'?: string;
    /**
     * Product status (catalog lifecycle)
     */
    'status'?: UpdateProductDtoStatusEnum;
}

export const UpdateProductDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Discontinued: 'discontinued'
} as const;

export type UpdateProductDtoStatusEnum = typeof UpdateProductDtoStatusEnum[keyof typeof UpdateProductDtoStatusEnum];

export interface UpdateProductStatusDto {
    /**
     * New product status
     */
    'status': UpdateProductStatusDtoStatusEnum;
}

export const UpdateProductStatusDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Discontinued: 'discontinued'
} as const;

export type UpdateProductStatusDtoStatusEnum = typeof UpdateProductStatusDtoStatusEnum[keyof typeof UpdateProductStatusDtoStatusEnum];

export interface UpdateUserDto {
    /**
     * User name
     */
    'name'?: string;
    /**
     * User email
     */
    'email'?: string;
    /**
     * User phone
     */
    'phone'?: string;
    /**
     * Date of birth
     */
    'dob'?: string;
    /**
     * Gender
     */
    'gender'?: UpdateUserDtoGenderEnum;
}

export const UpdateUserDtoGenderEnum = {
    Male: 'male',
    Female: 'female',
    Other: 'other'
} as const;

export type UpdateUserDtoGenderEnum = typeof UpdateUserDtoGenderEnum[keyof typeof UpdateUserDtoGenderEnum];

export interface UpdateUserStatusDto {
    /**
     * Account status
     */
    'status': UpdateUserStatusDtoStatusEnum;
}

export const UpdateUserStatusDtoStatusEnum = {
    Active: 'active',
    Suspended: 'suspended',
    Disabled: 'disabled'
} as const;

export type UpdateUserStatusDtoStatusEnum = typeof UpdateUserStatusDtoStatusEnum[keyof typeof UpdateUserStatusDtoStatusEnum];

export interface UpdateVariantDto {
    /**
     * Variant name
     */
    'variantName'?: string;
    /**
     * Price (base price before discount)
     */
    'price'?: number;
    /**
     * Discount percentage (0-100, set to 0 to remove discount)
     */
    'discountPercent'?: number;
    /**
     * Stock quantity
     */
    'stock'?: number;
    /**
     * Variant status
     */
    'status'?: UpdateVariantDtoStatusEnum;
    /**
     * Whether variant is active (available for purchase)
     */
    'isActive'?: boolean;
    /**
     * Seller profile ID (null to remove seller)
     */
    'sellerProfileId'?: object | null;
    /**
     * Additional attributes (e.g., weight, organic flag)
     */
    'attributes'?: object;
}

export const UpdateVariantDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    OutOfStock: 'out_of_stock'
} as const;

export type UpdateVariantDtoStatusEnum = typeof UpdateVariantDtoStatusEnum[keyof typeof UpdateVariantDtoStatusEnum];

export interface UpdateVariantStockDto {
    /**
     * Stock action type
     */
    'action': UpdateVariantStockDtoActionEnum;
    /**
     * Stock quantity
     */
    'quantity': number;
}

export const UpdateVariantStockDtoActionEnum = {
    Set: 'set',
    Add: 'add',
    Reduce: 'reduce'
} as const;

export type UpdateVariantStockDtoActionEnum = typeof UpdateVariantStockDtoActionEnum[keyof typeof UpdateVariantStockDtoActionEnum];

export interface UploadVariantImageResponseDto {
    /**
     * Image storage provider
     */
    'provider': UploadVariantImageResponseDtoProviderEnum;
    /**
     * URL of the storage bucket to upload the image to
     */
    'uploadUrl': string;
    /**
     * HTTP method to use for upload
     */
    'method': string;
    /**
     * URL to read/access the uploaded image
     */
    'readUrl'?: string;
    /**
     * Additional fields required for the upload
     */
    'fields'?: object;
}

export const UploadVariantImageResponseDtoProviderEnum = {
    Cloudinary: 'cloudinary',
    Azure: 'azure'
} as const;

export type UploadVariantImageResponseDtoProviderEnum = typeof UploadVariantImageResponseDtoProviderEnum[keyof typeof UploadVariantImageResponseDtoProviderEnum];

export interface UserControllerFindAll200Response {
    'message': string;
    'data': Array<UserResponseDto>;
    /**
     * Pagination metadata
     */
    'meta': PaginationMetaDto;
}
export interface UserControllerGetMe200Response {
    'message': string;
    'data': MeResponseDto;
}
export interface UserControllerUpdate200Response {
    'message': string;
    'data': UserResponseDto;
}
export interface UserResponseDto {
    'id': string;
    /**
     * Email address of the user. Optional if the user registered with phone number.
     */
    'email'?: string | null;
    /**
     * Phone number of the user. Optional if the user registered with email address.
     */
    'phone': string | null;
    'role': UserResponseDtoRoleEnum;
    'status': UserResponseDtoStatusEnum;
    'createdAt': string;
    'updatedAt': string;
}

export const UserResponseDtoRoleEnum = {
    Admin: 'ADMIN',
    Seller: 'SELLER',
    Customer: 'CUSTOMER'
} as const;

export type UserResponseDtoRoleEnum = typeof UserResponseDtoRoleEnum[keyof typeof UserResponseDtoRoleEnum];
export const UserResponseDtoStatusEnum = {
    Active: 'active',
    Suspended: 'suspended',
    Disabled: 'disabled'
} as const;

export type UserResponseDtoStatusEnum = typeof UserResponseDtoStatusEnum[keyof typeof UserResponseDtoStatusEnum];

export interface ValidateCouponDto {
    /**
     * Coupon code to validate
     */
    'code': string;
    /**
     * Current cart total amount
     */
    'cartTotal': number;
}
export interface VariantControllerCreateVariant201Response {
    'message': string;
    'data': VariantResponseDto;
}
export interface VariantControllerGetVariantsByProduct200Response {
    'message': string;
    'data': Array<VariantResponseDto>;
}
export interface VariantControllerUploadVariantImage201Response {
    'message': string;
    'data': UploadVariantImageResponseDto;
}
export interface VariantPreviewDto {
    /**
     * Variant ID
     */
    'id': string;
    /**
     * Variant name
     */
    'variantName': string;
    /**
     * Base price
     */
    'price': number;
    /**
     * Discount percentage
     */
    'discountPercent': number;
    /**
     * Final price after discount
     */
    'finalPrice': number;
    /**
     * Stock quantity
     */
    'stock': number;
    /**
     * Single image URL (first image)
     */
    'imageUrl'?: string;
    /**
     * Whether variant is available for purchase
     */
    'availableForPurchase': boolean;
}
export interface VariantResponseDto {
    /**
     * Variant ID
     */
    'id': string;
    /**
     * Product ID
     */
    'productId': string;
    /**
     * Variant name
     */
    'variantName': string;
    /**
     * Base price
     */
    'price': number;
    /**
     * Discount percentage
     */
    'discountPercent': number;
    /**
     * Final price after discount
     */
    'finalPrice': number;
    /**
     * Stock quantity
     */
    'stock': number;
    /**
     * Variant status
     */
    'status': VariantResponseDtoStatusEnum;
    /**
     * Whether variant is active
     */
    'isActive': boolean;
    /**
     * Whether variant is in stock
     */
    'inStock': boolean;
    /**
     * Whether variant is available for purchase
     */
    'availableForPurchase': boolean;
    /**
     * Seller profile ID
     */
    'sellerProfileId'?: object | null;
    /**
     * Additional attributes
     */
    'attributes'?: object | null;
    /**
     * Image URLs (array of strings, max 6)
     */
    'images': Array<string>;
    /**
     * Creation date
     */
    'createdAt': string;
    /**
     * Last update date
     */
    'updatedAt': string;
}

export const VariantResponseDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    OutOfStock: 'out_of_stock'
} as const;

export type VariantResponseDtoStatusEnum = typeof VariantResponseDtoStatusEnum[keyof typeof VariantResponseDtoStatusEnum];

export interface VerifyOTPDto {
    /**
     * Email or phone number
     */
    'identifier': string;
    /**
     * OTP code (4 digits)
     */
    'otp': string;
}

/**
 * AddressesApi - axios parameter creator
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new address for the authenticated user
         * @summary Create address
         * @param {CreateAddressDto} createAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerCreate: async (createAddressDto: CreateAddressDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAddressDto' is not null or undefined
            assertParamExists('addressControllerCreate', 'createAddressDto', createAddressDto)
            const localVarPath = `/api/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAddressDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing address for the authenticated user
         * @summary Delete address
         * @param {string} id Address UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addressControllerDelete', 'id', id)
            const localVarPath = `/api/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all addresses associated with the authenticated user
         * @summary Get my addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerFind: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing address for the authenticated user
         * @summary Update address
         * @param {string} id Address UUID
         * @param {UpdateAddressDto} updateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerUpdate: async (id: string, updateAddressDto: UpdateAddressDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addressControllerUpdate', 'id', id)
            // verify required parameter 'updateAddressDto' is not null or undefined
            assertParamExists('addressControllerUpdate', 'updateAddressDto', updateAddressDto)
            const localVarPath = `/api/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAddressDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 */
export const AddressesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new address for the authenticated user
         * @summary Create address
         * @param {CreateAddressDto} createAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressControllerCreate(createAddressDto: CreateAddressDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressControllerCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressControllerCreate(createAddressDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.addressControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an existing address for the authenticated user
         * @summary Delete address
         * @param {string} id Address UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressControllerDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressControllerDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressControllerDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.addressControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all addresses associated with the authenticated user
         * @summary Get my addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressControllerFind(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressControllerFind200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressControllerFind(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.addressControllerFind']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing address for the authenticated user
         * @summary Update address
         * @param {string} id Address UUID
         * @param {UpdateAddressDto} updateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressControllerUpdate(id: string, updateAddressDto: UpdateAddressDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressControllerCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressControllerUpdate(id, updateAddressDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.addressControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressesApi - factory interface
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressesApiFp(configuration)
    return {
        /**
         * Creates a new address for the authenticated user
         * @summary Create address
         * @param {CreateAddressDto} createAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerCreate(createAddressDto: CreateAddressDto, options?: RawAxiosRequestConfig): AxiosPromise<AddressControllerCreate201Response> {
            return localVarFp.addressControllerCreate(createAddressDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing address for the authenticated user
         * @summary Delete address
         * @param {string} id Address UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressControllerDelete200Response> {
            return localVarFp.addressControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all addresses associated with the authenticated user
         * @summary Get my addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerFind(options?: RawAxiosRequestConfig): AxiosPromise<AddressControllerFind200Response> {
            return localVarFp.addressControllerFind(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing address for the authenticated user
         * @summary Update address
         * @param {string} id Address UUID
         * @param {UpdateAddressDto} updateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerUpdate(id: string, updateAddressDto: UpdateAddressDto, options?: RawAxiosRequestConfig): AxiosPromise<AddressControllerCreate201Response> {
            return localVarFp.addressControllerUpdate(id, updateAddressDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressesApi - object-oriented interface
 */
export class AddressesApi extends BaseAPI {
    /**
     * Creates a new address for the authenticated user
     * @summary Create address
     * @param {CreateAddressDto} createAddressDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressControllerCreate(createAddressDto: CreateAddressDto, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).addressControllerCreate(createAddressDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing address for the authenticated user
     * @summary Delete address
     * @param {string} id Address UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressControllerDelete(id: string, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).addressControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all addresses associated with the authenticated user
     * @summary Get my addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressControllerFind(options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).addressControllerFind(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing address for the authenticated user
     * @summary Update address
     * @param {string} id Address UUID
     * @param {UpdateAddressDto} updateAddressDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressControllerUpdate(id: string, updateAddressDto: UpdateAddressDto, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).addressControllerUpdate(id, updateAddressDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminCouponsApi - axios parameter creator
 */
export const AdminCouponsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a coupon to make it available for use
         * @summary Activate coupon
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerActivate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminCouponControllerActivate', 'id', id)
            const localVarPath = `/api/admin/coupons/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new discount coupon with usage limits and validation rules
         * @summary Create new coupon
         * @param {CreateCouponDto} createCouponDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerCreate: async (createCouponDto: CreateCouponDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCouponDto' is not null or undefined
            assertParamExists('adminCouponControllerCreate', 'createCouponDto', createCouponDto)
            const localVarPath = `/api/admin/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCouponDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate a coupon to prevent further use
         * @summary Deactivate coupon
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerDeactivate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminCouponControllerDeactivate', 'id', id)
            const localVarPath = `/api/admin/coupons/{id}/deactivate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all coupons with pagination
         * @summary Get all coupons
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerFindAll: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information about a specific coupon
         * @summary Get coupon by ID
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminCouponControllerFindOne', 'id', id)
            const localVarPath = `/api/admin/coupons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve analytics and performance metrics for all coupons including usage stats, revenue impact, and top performers
         * @summary Get coupon performance analytics
         * @param {string} [startDate] Start date for analytics period (ISO format)
         * @param {string} [endDate] End date for analytics period (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerGetCouponAnalytics: async (startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/coupons/analytics/performance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed usage history for a specific coupon
         * @summary Get coupon usage history
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerGetUsageHistory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminCouponControllerGetUsageHistory', 'id', id)
            const localVarPath = `/api/admin/coupons/{id}/usage`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update coupon details and configuration
         * @summary Update coupon
         * @param {string} id Coupon ID
         * @param {UpdateCouponDto} updateCouponDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerUpdate: async (id: string, updateCouponDto: UpdateCouponDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminCouponControllerUpdate', 'id', id)
            // verify required parameter 'updateCouponDto' is not null or undefined
            assertParamExists('adminCouponControllerUpdate', 'updateCouponDto', updateCouponDto)
            const localVarPath = `/api/admin/coupons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCouponDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminCouponsApi - functional programming interface
 */
export const AdminCouponsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminCouponsApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate a coupon to make it available for use
         * @summary Activate coupon
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCouponControllerActivate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCouponControllerActivate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminCouponsApi.adminCouponControllerActivate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new discount coupon with usage limits and validation rules
         * @summary Create new coupon
         * @param {CreateCouponDto} createCouponDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCouponControllerCreate(createCouponDto: CreateCouponDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponControllerGetCouponByCode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCouponControllerCreate(createCouponDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminCouponsApi.adminCouponControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivate a coupon to prevent further use
         * @summary Deactivate coupon
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCouponControllerDeactivate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCouponControllerDeactivate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminCouponsApi.adminCouponControllerDeactivate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all coupons with pagination
         * @summary Get all coupons
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCouponControllerFindAll(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponControllerGetAvailableCoupons200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCouponControllerFindAll(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminCouponsApi.adminCouponControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information about a specific coupon
         * @summary Get coupon by ID
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCouponControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponControllerGetCouponByCode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCouponControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminCouponsApi.adminCouponControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve analytics and performance metrics for all coupons including usage stats, revenue impact, and top performers
         * @summary Get coupon performance analytics
         * @param {string} [startDate] Start date for analytics period (ISO format)
         * @param {string} [endDate] End date for analytics period (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCouponControllerGetCouponAnalytics(startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCouponControllerGetCouponAnalytics(startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminCouponsApi.adminCouponControllerGetCouponAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed usage history for a specific coupon
         * @summary Get coupon usage history
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCouponControllerGetUsageHistory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminCouponControllerGetUsageHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCouponControllerGetUsageHistory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminCouponsApi.adminCouponControllerGetUsageHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update coupon details and configuration
         * @summary Update coupon
         * @param {string} id Coupon ID
         * @param {UpdateCouponDto} updateCouponDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCouponControllerUpdate(id: string, updateCouponDto: UpdateCouponDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponControllerGetCouponByCode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCouponControllerUpdate(id, updateCouponDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminCouponsApi.adminCouponControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminCouponsApi - factory interface
 */
export const AdminCouponsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminCouponsApiFp(configuration)
    return {
        /**
         * Activate a coupon to make it available for use
         * @summary Activate coupon
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerActivate(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.adminCouponControllerActivate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new discount coupon with usage limits and validation rules
         * @summary Create new coupon
         * @param {CreateCouponDto} createCouponDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerCreate(createCouponDto: CreateCouponDto, options?: RawAxiosRequestConfig): AxiosPromise<CouponControllerGetCouponByCode200Response> {
            return localVarFp.adminCouponControllerCreate(createCouponDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate a coupon to prevent further use
         * @summary Deactivate coupon
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerDeactivate(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.adminCouponControllerDeactivate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all coupons with pagination
         * @summary Get all coupons
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerFindAll(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<CouponControllerGetAvailableCoupons200Response> {
            return localVarFp.adminCouponControllerFindAll(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information about a specific coupon
         * @summary Get coupon by ID
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CouponControllerGetCouponByCode200Response> {
            return localVarFp.adminCouponControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve analytics and performance metrics for all coupons including usage stats, revenue impact, and top performers
         * @summary Get coupon performance analytics
         * @param {string} [startDate] Start date for analytics period (ISO format)
         * @param {string} [endDate] End date for analytics period (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerGetCouponAnalytics(startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.adminCouponControllerGetCouponAnalytics(startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed usage history for a specific coupon
         * @summary Get coupon usage history
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerGetUsageHistory(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AdminCouponControllerGetUsageHistory200Response> {
            return localVarFp.adminCouponControllerGetUsageHistory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update coupon details and configuration
         * @summary Update coupon
         * @param {string} id Coupon ID
         * @param {UpdateCouponDto} updateCouponDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCouponControllerUpdate(id: string, updateCouponDto: UpdateCouponDto, options?: RawAxiosRequestConfig): AxiosPromise<CouponControllerGetCouponByCode200Response> {
            return localVarFp.adminCouponControllerUpdate(id, updateCouponDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminCouponsApi - object-oriented interface
 */
export class AdminCouponsApi extends BaseAPI {
    /**
     * Activate a coupon to make it available for use
     * @summary Activate coupon
     * @param {string} id Coupon ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminCouponControllerActivate(id: string, options?: RawAxiosRequestConfig) {
        return AdminCouponsApiFp(this.configuration).adminCouponControllerActivate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new discount coupon with usage limits and validation rules
     * @summary Create new coupon
     * @param {CreateCouponDto} createCouponDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminCouponControllerCreate(createCouponDto: CreateCouponDto, options?: RawAxiosRequestConfig) {
        return AdminCouponsApiFp(this.configuration).adminCouponControllerCreate(createCouponDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate a coupon to prevent further use
     * @summary Deactivate coupon
     * @param {string} id Coupon ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminCouponControllerDeactivate(id: string, options?: RawAxiosRequestConfig) {
        return AdminCouponsApiFp(this.configuration).adminCouponControllerDeactivate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all coupons with pagination
     * @summary Get all coupons
     * @param {number} [page] Page number
     * @param {number} [limit] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminCouponControllerFindAll(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return AdminCouponsApiFp(this.configuration).adminCouponControllerFindAll(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information about a specific coupon
     * @summary Get coupon by ID
     * @param {string} id Coupon ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminCouponControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return AdminCouponsApiFp(this.configuration).adminCouponControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve analytics and performance metrics for all coupons including usage stats, revenue impact, and top performers
     * @summary Get coupon performance analytics
     * @param {string} [startDate] Start date for analytics period (ISO format)
     * @param {string} [endDate] End date for analytics period (ISO format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminCouponControllerGetCouponAnalytics(startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return AdminCouponsApiFp(this.configuration).adminCouponControllerGetCouponAnalytics(startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed usage history for a specific coupon
     * @summary Get coupon usage history
     * @param {string} id Coupon ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminCouponControllerGetUsageHistory(id: string, options?: RawAxiosRequestConfig) {
        return AdminCouponsApiFp(this.configuration).adminCouponControllerGetUsageHistory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update coupon details and configuration
     * @summary Update coupon
     * @param {string} id Coupon ID
     * @param {UpdateCouponDto} updateCouponDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminCouponControllerUpdate(id: string, updateCouponDto: UpdateCouponDto, options?: RawAxiosRequestConfig) {
        return AdminCouponsApiFp(this.configuration).adminCouponControllerUpdate(id, updateCouponDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminOffersApi - axios parameter creator
 */
export const AdminOffersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate an offer to make it available
         * @summary Activate offer
         * @param {string} id Offer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOfferControllerActivate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminOfferControllerActivate', 'id', id)
            const localVarPath = `/api/admin/offers/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new promotional offer with priority and applicability rules
         * @summary Create new offer
         * @param {CreateOfferDto} createOfferDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOfferControllerCreate: async (createOfferDto: CreateOfferDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOfferDto' is not null or undefined
            assertParamExists('adminOfferControllerCreate', 'createOfferDto', createOfferDto)
            const localVarPath = `/api/admin/offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOfferDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate an offer to prevent it from being applied
         * @summary Deactivate offer
         * @param {string} id Offer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOfferControllerDeactivate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminOfferControllerDeactivate', 'id', id)
            const localVarPath = `/api/admin/offers/{id}/deactivate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all offers with pagination
         * @summary Get all offers
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOfferControllerFindAll: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information about a specific offer
         * @summary Get offer by ID
         * @param {string} id Offer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOfferControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminOfferControllerFindOne', 'id', id)
            const localVarPath = `/api/admin/offers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update offer details and configuration
         * @summary Update offer
         * @param {string} id Offer ID
         * @param {UpdateOfferDto} updateOfferDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOfferControllerUpdate: async (id: string, updateOfferDto: UpdateOfferDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminOfferControllerUpdate', 'id', id)
            // verify required parameter 'updateOfferDto' is not null or undefined
            assertParamExists('adminOfferControllerUpdate', 'updateOfferDto', updateOfferDto)
            const localVarPath = `/api/admin/offers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOfferDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminOffersApi - functional programming interface
 */
export const AdminOffersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminOffersApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate an offer to make it available
         * @summary Activate offer
         * @param {string} id Offer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOfferControllerActivate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOfferControllerActivate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminOffersApi.adminOfferControllerActivate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new promotional offer with priority and applicability rules
         * @summary Create new offer
         * @param {CreateOfferDto} createOfferDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOfferControllerCreate(createOfferDto: CreateOfferDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferControllerGetOffer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOfferControllerCreate(createOfferDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminOffersApi.adminOfferControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivate an offer to prevent it from being applied
         * @summary Deactivate offer
         * @param {string} id Offer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOfferControllerDeactivate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOfferControllerDeactivate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminOffersApi.adminOfferControllerDeactivate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all offers with pagination
         * @summary Get all offers
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOfferControllerFindAll(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferControllerGetActiveOffers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOfferControllerFindAll(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminOffersApi.adminOfferControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information about a specific offer
         * @summary Get offer by ID
         * @param {string} id Offer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOfferControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferControllerGetOffer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOfferControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminOffersApi.adminOfferControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update offer details and configuration
         * @summary Update offer
         * @param {string} id Offer ID
         * @param {UpdateOfferDto} updateOfferDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOfferControllerUpdate(id: string, updateOfferDto: UpdateOfferDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferControllerGetOffer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOfferControllerUpdate(id, updateOfferDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminOffersApi.adminOfferControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminOffersApi - factory interface
 */
export const AdminOffersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminOffersApiFp(configuration)
    return {
        /**
         * Activate an offer to make it available
         * @summary Activate offer
         * @param {string} id Offer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOfferControllerActivate(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.adminOfferControllerActivate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new promotional offer with priority and applicability rules
         * @summary Create new offer
         * @param {CreateOfferDto} createOfferDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOfferControllerCreate(createOfferDto: CreateOfferDto, options?: RawAxiosRequestConfig): AxiosPromise<OfferControllerGetOffer200Response> {
            return localVarFp.adminOfferControllerCreate(createOfferDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate an offer to prevent it from being applied
         * @summary Deactivate offer
         * @param {string} id Offer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOfferControllerDeactivate(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.adminOfferControllerDeactivate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all offers with pagination
         * @summary Get all offers
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOfferControllerFindAll(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<OfferControllerGetActiveOffers200Response> {
            return localVarFp.adminOfferControllerFindAll(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information about a specific offer
         * @summary Get offer by ID
         * @param {string} id Offer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOfferControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<OfferControllerGetOffer200Response> {
            return localVarFp.adminOfferControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update offer details and configuration
         * @summary Update offer
         * @param {string} id Offer ID
         * @param {UpdateOfferDto} updateOfferDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOfferControllerUpdate(id: string, updateOfferDto: UpdateOfferDto, options?: RawAxiosRequestConfig): AxiosPromise<OfferControllerGetOffer200Response> {
            return localVarFp.adminOfferControllerUpdate(id, updateOfferDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminOffersApi - object-oriented interface
 */
export class AdminOffersApi extends BaseAPI {
    /**
     * Activate an offer to make it available
     * @summary Activate offer
     * @param {string} id Offer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminOfferControllerActivate(id: string, options?: RawAxiosRequestConfig) {
        return AdminOffersApiFp(this.configuration).adminOfferControllerActivate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new promotional offer with priority and applicability rules
     * @summary Create new offer
     * @param {CreateOfferDto} createOfferDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminOfferControllerCreate(createOfferDto: CreateOfferDto, options?: RawAxiosRequestConfig) {
        return AdminOffersApiFp(this.configuration).adminOfferControllerCreate(createOfferDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate an offer to prevent it from being applied
     * @summary Deactivate offer
     * @param {string} id Offer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminOfferControllerDeactivate(id: string, options?: RawAxiosRequestConfig) {
        return AdminOffersApiFp(this.configuration).adminOfferControllerDeactivate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all offers with pagination
     * @summary Get all offers
     * @param {number} [page] Page number
     * @param {number} [limit] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminOfferControllerFindAll(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return AdminOffersApiFp(this.configuration).adminOfferControllerFindAll(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information about a specific offer
     * @summary Get offer by ID
     * @param {string} id Offer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminOfferControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return AdminOffersApiFp(this.configuration).adminOfferControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update offer details and configuration
     * @summary Update offer
     * @param {string} id Offer ID
     * @param {UpdateOfferDto} updateOfferDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminOfferControllerUpdate(id: string, updateOfferDto: UpdateOfferDto, options?: RawAxiosRequestConfig) {
        return AdminOffersApiFp(this.configuration).adminOfferControllerUpdate(id, updateOfferDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminOrdersApi - axios parameter creator
 */
export const AdminOrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all orders with optional filtering
         * @summary Get all orders
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {AdminOrderControllerGetAllOrdersStatusEnum} [status] Filter by order status
         * @param {string} [customerId] Filter by customer ID
         * @param {string} [startDate] Filter from date (ISO string)
         * @param {string} [endDate] Filter to date (ISO string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOrderControllerGetAllOrders: async (page?: number, limit?: number, status?: AdminOrderControllerGetAllOrdersStatusEnum, customerId?: string, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information about a specific order
         * @summary Get order by ID
         * @param {string} id Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOrderControllerGetOrderById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminOrderControllerGetOrderById', 'id', id)
            const localVarPath = `/api/admin/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the status of an order
         * @summary Update order status
         * @param {string} id Order ID
         * @param {UpdateOrderStatusDto} updateOrderStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOrderControllerUpdateOrderStatus: async (id: string, updateOrderStatusDto: UpdateOrderStatusDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminOrderControllerUpdateOrderStatus', 'id', id)
            // verify required parameter 'updateOrderStatusDto' is not null or undefined
            assertParamExists('adminOrderControllerUpdateOrderStatus', 'updateOrderStatusDto', updateOrderStatusDto)
            const localVarPath = `/api/admin/orders/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrderStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminOrdersApi - functional programming interface
 */
export const AdminOrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminOrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all orders with optional filtering
         * @summary Get all orders
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {AdminOrderControllerGetAllOrdersStatusEnum} [status] Filter by order status
         * @param {string} [customerId] Filter by customer ID
         * @param {string} [startDate] Filter from date (ISO string)
         * @param {string} [endDate] Filter to date (ISO string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOrderControllerGetAllOrders(page?: number, limit?: number, status?: AdminOrderControllerGetAllOrdersStatusEnum, customerId?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerOrderControllerGetMyOrders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOrderControllerGetAllOrders(page, limit, status, customerId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminOrdersApi.adminOrderControllerGetAllOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information about a specific order
         * @summary Get order by ID
         * @param {string} id Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOrderControllerGetOrderById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerOrderControllerCancelOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOrderControllerGetOrderById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminOrdersApi.adminOrderControllerGetOrderById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the status of an order
         * @summary Update order status
         * @param {string} id Order ID
         * @param {UpdateOrderStatusDto} updateOrderStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOrderControllerUpdateOrderStatus(id: string, updateOrderStatusDto: UpdateOrderStatusDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerOrderControllerCancelOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOrderControllerUpdateOrderStatus(id, updateOrderStatusDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminOrdersApi.adminOrderControllerUpdateOrderStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminOrdersApi - factory interface
 */
export const AdminOrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminOrdersApiFp(configuration)
    return {
        /**
         * Retrieve all orders with optional filtering
         * @summary Get all orders
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {AdminOrderControllerGetAllOrdersStatusEnum} [status] Filter by order status
         * @param {string} [customerId] Filter by customer ID
         * @param {string} [startDate] Filter from date (ISO string)
         * @param {string} [endDate] Filter to date (ISO string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOrderControllerGetAllOrders(page?: number, limit?: number, status?: AdminOrderControllerGetAllOrdersStatusEnum, customerId?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomerOrderControllerGetMyOrders200Response> {
            return localVarFp.adminOrderControllerGetAllOrders(page, limit, status, customerId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information about a specific order
         * @summary Get order by ID
         * @param {string} id Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOrderControllerGetOrderById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomerOrderControllerCancelOrder200Response> {
            return localVarFp.adminOrderControllerGetOrderById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of an order
         * @summary Update order status
         * @param {string} id Order ID
         * @param {UpdateOrderStatusDto} updateOrderStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOrderControllerUpdateOrderStatus(id: string, updateOrderStatusDto: UpdateOrderStatusDto, options?: RawAxiosRequestConfig): AxiosPromise<CustomerOrderControllerCancelOrder200Response> {
            return localVarFp.adminOrderControllerUpdateOrderStatus(id, updateOrderStatusDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminOrdersApi - object-oriented interface
 */
export class AdminOrdersApi extends BaseAPI {
    /**
     * Retrieve all orders with optional filtering
     * @summary Get all orders
     * @param {number} [page] Page number
     * @param {number} [limit] Items per page
     * @param {AdminOrderControllerGetAllOrdersStatusEnum} [status] Filter by order status
     * @param {string} [customerId] Filter by customer ID
     * @param {string} [startDate] Filter from date (ISO string)
     * @param {string} [endDate] Filter to date (ISO string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminOrderControllerGetAllOrders(page?: number, limit?: number, status?: AdminOrderControllerGetAllOrdersStatusEnum, customerId?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return AdminOrdersApiFp(this.configuration).adminOrderControllerGetAllOrders(page, limit, status, customerId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information about a specific order
     * @summary Get order by ID
     * @param {string} id Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminOrderControllerGetOrderById(id: string, options?: RawAxiosRequestConfig) {
        return AdminOrdersApiFp(this.configuration).adminOrderControllerGetOrderById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the status of an order
     * @summary Update order status
     * @param {string} id Order ID
     * @param {UpdateOrderStatusDto} updateOrderStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminOrderControllerUpdateOrderStatus(id: string, updateOrderStatusDto: UpdateOrderStatusDto, options?: RawAxiosRequestConfig) {
        return AdminOrdersApiFp(this.configuration).adminOrderControllerUpdateOrderStatus(id, updateOrderStatusDto, options).then((request) => request(this.axios, this.basePath));
    }
}

export const AdminOrderControllerGetAllOrdersStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Shipping: 'shipping',
    Delivered: 'delivered',
    Canceled: 'canceled',
    ReturnRequested: 'return_requested',
    ReturnApproved: 'return_approved',
    ReturnRejected: 'return_rejected',
    Returned: 'returned'
} as const;
export type AdminOrderControllerGetAllOrdersStatusEnum = typeof AdminOrderControllerGetAllOrdersStatusEnum[keyof typeof AdminOrderControllerGetAllOrdersStatusEnum];


/**
 * AuthenticationApi - axios parameter creator
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate user with password or OTP
         * @summary Login with password or OTP
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate user with Google OAuth
         * @summary Login with Google
         * @param {LoginWithGoogleDto} loginWithGoogleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithGoogle: async (loginWithGoogleDto: LoginWithGoogleDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginWithGoogleDto' is not null or undefined
            assertParamExists('authControllerLoginWithGoogle', 'loginWithGoogleDto', loginWithGoogleDto)
            const localVarPath = `/api/auth/login/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginWithGoogleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear authentication cookies
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get new access token using refresh token
         * @summary Refresh access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new customer account with email/phone and password
         * @summary Register a new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister: async (registerDto: RegisterDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerDto' is not null or undefined
            assertParamExists('authControllerRegister', 'registerDto', registerDto)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send OTP to email or phone number
         * @summary Request OTP
         * @param {RequestOTPDto} requestOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRequestOTP: async (requestOTPDto: RequestOTPDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestOTPDto' is not null or undefined
            assertParamExists('authControllerRequestOTP', 'requestOTPDto', requestOTPDto)
            const localVarPath = `/api/auth/otp/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestOTPDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify OTP code
         * @summary Verify OTP
         * @param {VerifyOTPDto} verifyOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyOTP: async (verifyOTPDto: VerifyOTPDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyOTPDto' is not null or undefined
            assertParamExists('authControllerVerifyOTP', 'verifyOTPDto', verifyOTPDto)
            const localVarPath = `/api/auth/otp/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyOTPDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate user with password or OTP
         * @summary Login with password or OTP
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate user with Google OAuth
         * @summary Login with Google
         * @param {LoginWithGoogleDto} loginWithGoogleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLoginWithGoogle(loginWithGoogleDto: LoginWithGoogleDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLoginWithGoogle(loginWithGoogleDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLoginWithGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clear authentication cookies
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get new access token using refresh token
         * @summary Refresh access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefreshToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefreshToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerRefreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new customer account with email/phone and password
         * @summary Register a new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRegister(registerDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send OTP to email or phone number
         * @summary Request OTP
         * @param {RequestOTPDto} requestOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRequestOTP(requestOTPDto: RequestOTPDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRequestOTP(requestOTPDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerRequestOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify OTP code
         * @summary Verify OTP
         * @param {VerifyOTPDto} verifyOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerVerifyOTP(verifyOTPDto: VerifyOTPDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerifyOTP(verifyOTPDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerVerifyOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Authenticate user with password or OTP
         * @summary Login with password or OTP
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.authControllerLogin(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate user with Google OAuth
         * @summary Login with Google
         * @param {LoginWithGoogleDto} loginWithGoogleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithGoogle(loginWithGoogleDto: LoginWithGoogleDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.authControllerLoginWithGoogle(loginWithGoogleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Clear authentication cookies
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout(options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.authControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Get new access token using refresh token
         * @summary Refresh access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken(options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.authControllerRefreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new customer account with email/phone and password
         * @summary Register a new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.authControllerRegister(registerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Send OTP to email or phone number
         * @summary Request OTP
         * @param {RequestOTPDto} requestOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRequestOTP(requestOTPDto: RequestOTPDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.authControllerRequestOTP(requestOTPDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify OTP code
         * @summary Verify OTP
         * @param {VerifyOTPDto} verifyOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyOTP(verifyOTPDto: VerifyOTPDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.authControllerVerifyOTP(verifyOTPDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Authenticate user with password or OTP
     * @summary Login with password or OTP
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLogin(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate user with Google OAuth
     * @summary Login with Google
     * @param {LoginWithGoogleDto} loginWithGoogleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerLoginWithGoogle(loginWithGoogleDto: LoginWithGoogleDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLoginWithGoogle(loginWithGoogleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear authentication cookies
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerLogout(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get new access token using refresh token
     * @summary Refresh access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerRefreshToken(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerRefreshToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new customer account with email/phone and password
     * @summary Register a new user
     * @param {RegisterDto} registerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerRegister(registerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send OTP to email or phone number
     * @summary Request OTP
     * @param {RequestOTPDto} requestOTPDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerRequestOTP(requestOTPDto: RequestOTPDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerRequestOTP(requestOTPDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify OTP code
     * @summary Verify OTP
     * @param {VerifyOTPDto} verifyOTPDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerVerifyOTP(verifyOTPDto: VerifyOTPDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerVerifyOTP(verifyOTPDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CartApi - axios parameter creator
 */
export const CartApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add item to cart
         * @param {AddItemToCartDto} addItemToCartDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerAddItem: async (addItemToCartDto: AddItemToCartDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addItemToCartDto' is not null or undefined
            assertParamExists('cartControllerAddItem', 'addItemToCartDto', addItemToCartDto)
            const localVarPath = `/api/cart/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addItemToCartDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate and apply a coupon code to the cart
         * @summary Apply coupon to cart
         * @param {ApplyCouponDto} applyCouponDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerApplyCoupon: async (applyCouponDto: ApplyCouponDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applyCouponDto' is not null or undefined
            assertParamExists('cartControllerApplyCoupon', 'applyCouponDto', applyCouponDto)
            const localVarPath = `/api/cart/apply-coupon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applyCouponDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clear all items from cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerClearCart: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cart/clear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user cart with product details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerGetCart: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculate cart pricing including active offers and optional coupon discount. Returns complete breakdown of all discounts.
         * @summary Get cart pricing with offers and optional coupon
         * @param {string} [couponCode] Coupon code to apply for pricing calculation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerGetCartPricing: async (couponCode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cart/pricing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (couponCode !== undefined) {
                localVarQueryParameter['couponCode'] = couponCode;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove item from cart
         * @param {string} itemId Cart item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerRemoveItem: async (itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('cartControllerRemoveItem', 'itemId', itemId)
            const localVarPath = `/api/cart/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update cart item quantity
         * @param {string} itemId Cart item ID
         * @param {UpdateCartItemDto} updateCartItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerUpdateItem: async (itemId: string, updateCartItemDto: UpdateCartItemDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('cartControllerUpdateItem', 'itemId', itemId)
            // verify required parameter 'updateCartItemDto' is not null or undefined
            assertParamExists('cartControllerUpdateItem', 'updateCartItemDto', updateCartItemDto)
            const localVarPath = `/api/cart/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCartItemDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CartApi - functional programming interface
 */
export const CartApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CartApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add item to cart
         * @param {AddItemToCartDto} addItemToCartDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerAddItem(addItemToCartDto: AddItemToCartDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartControllerAddItem201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerAddItem(addItemToCartDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerAddItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validate and apply a coupon code to the cart
         * @summary Apply coupon to cart
         * @param {ApplyCouponDto} applyCouponDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerApplyCoupon(applyCouponDto: ApplyCouponDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerApplyCoupon(applyCouponDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerApplyCoupon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Clear all items from cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerClearCart(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerClearCart(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerClearCart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user cart with product details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerGetCart(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartControllerGetCart200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerGetCart(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerGetCart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Calculate cart pricing including active offers and optional coupon discount. Returns complete breakdown of all discounts.
         * @summary Get cart pricing with offers and optional coupon
         * @param {string} [couponCode] Coupon code to apply for pricing calculation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerGetCartPricing(couponCode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartControllerGetCartPricing200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerGetCartPricing(couponCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerGetCartPricing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove item from cart
         * @param {string} itemId Cart item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerRemoveItem(itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerRemoveItem(itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerRemoveItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update cart item quantity
         * @param {string} itemId Cart item ID
         * @param {UpdateCartItemDto} updateCartItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerUpdateItem(itemId: string, updateCartItemDto: UpdateCartItemDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartControllerAddItem201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerUpdateItem(itemId, updateCartItemDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerUpdateItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CartApi - factory interface
 */
export const CartApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CartApiFp(configuration)
    return {
        /**
         * 
         * @summary Add item to cart
         * @param {AddItemToCartDto} addItemToCartDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerAddItem(addItemToCartDto: AddItemToCartDto, options?: RawAxiosRequestConfig): AxiosPromise<CartControllerAddItem201Response> {
            return localVarFp.cartControllerAddItem(addItemToCartDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate and apply a coupon code to the cart
         * @summary Apply coupon to cart
         * @param {ApplyCouponDto} applyCouponDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerApplyCoupon(applyCouponDto: ApplyCouponDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.cartControllerApplyCoupon(applyCouponDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clear all items from cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerClearCart(options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.cartControllerClearCart(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user cart with product details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerGetCart(options?: RawAxiosRequestConfig): AxiosPromise<CartControllerGetCart200Response> {
            return localVarFp.cartControllerGetCart(options).then((request) => request(axios, basePath));
        },
        /**
         * Calculate cart pricing including active offers and optional coupon discount. Returns complete breakdown of all discounts.
         * @summary Get cart pricing with offers and optional coupon
         * @param {string} [couponCode] Coupon code to apply for pricing calculation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerGetCartPricing(couponCode?: string, options?: RawAxiosRequestConfig): AxiosPromise<CartControllerGetCartPricing200Response> {
            return localVarFp.cartControllerGetCartPricing(couponCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove item from cart
         * @param {string} itemId Cart item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerRemoveItem(itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.cartControllerRemoveItem(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update cart item quantity
         * @param {string} itemId Cart item ID
         * @param {UpdateCartItemDto} updateCartItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerUpdateItem(itemId: string, updateCartItemDto: UpdateCartItemDto, options?: RawAxiosRequestConfig): AxiosPromise<CartControllerAddItem201Response> {
            return localVarFp.cartControllerUpdateItem(itemId, updateCartItemDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CartApi - object-oriented interface
 */
export class CartApi extends BaseAPI {
    /**
     * 
     * @summary Add item to cart
     * @param {AddItemToCartDto} addItemToCartDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cartControllerAddItem(addItemToCartDto: AddItemToCartDto, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerAddItem(addItemToCartDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate and apply a coupon code to the cart
     * @summary Apply coupon to cart
     * @param {ApplyCouponDto} applyCouponDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cartControllerApplyCoupon(applyCouponDto: ApplyCouponDto, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerApplyCoupon(applyCouponDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clear all items from cart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cartControllerClearCart(options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerClearCart(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user cart with product details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cartControllerGetCart(options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerGetCart(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calculate cart pricing including active offers and optional coupon discount. Returns complete breakdown of all discounts.
     * @summary Get cart pricing with offers and optional coupon
     * @param {string} [couponCode] Coupon code to apply for pricing calculation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cartControllerGetCartPricing(couponCode?: string, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerGetCartPricing(couponCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove item from cart
     * @param {string} itemId Cart item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cartControllerRemoveItem(itemId: string, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerRemoveItem(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update cart item quantity
     * @param {string} itemId Cart item ID
     * @param {UpdateCartItemDto} updateCartItemDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cartControllerUpdateItem(itemId: string, updateCartItemDto: UpdateCartItemDto, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerUpdateItem(itemId, updateCartItemDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoriesApi - axios parameter creator
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new category with the provided details. Only admins can create categories.
         * @summary Create a new category
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerCreate: async (createCategoryDto: CreateCategoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCategoryDto' is not null or undefined
            assertParamExists('categoryControllerCreate', 'createCategoryDto', createCategoryDto)
            const localVarPath = `/api/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all categories
         * @summary Get all categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single category by its ID
         * @summary Get category by ID
         * @param {string} id Category CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoryControllerFindOne', 'id', id)
            const localVarPath = `/api/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a category. Only admins can delete categories.
         * @summary Delete category
         * @param {string} id Category CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoryControllerRemove', 'id', id)
            const localVarPath = `/api/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing category. Only admins can update categories.
         * @summary Update category
         * @param {string} id Category CUID
         * @param {UpdateCategoryDto} updateCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerUpdate: async (id: string, updateCategoryDto: UpdateCategoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoryControllerUpdate', 'id', id)
            // verify required parameter 'updateCategoryDto' is not null or undefined
            assertParamExists('categoryControllerUpdate', 'updateCategoryDto', updateCategoryDto)
            const localVarPath = `/api/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new category with the provided details. Only admins can create categories.
         * @summary Create a new category
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerCreate(createCategoryDto: CreateCategoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerCreate(createCategoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.categoryControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all categories
         * @summary Get all categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryControllerFindAll200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.categoryControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single category by its ID
         * @summary Get category by ID
         * @param {string} id Category CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.categoryControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a category. Only admins can delete categories.
         * @summary Delete category
         * @param {string} id Category CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.categoryControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing category. Only admins can update categories.
         * @summary Update category
         * @param {string} id Category CUID
         * @param {UpdateCategoryDto} updateCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerUpdate(id: string, updateCategoryDto: UpdateCategoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerUpdate(id, updateCategoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.categoryControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoriesApi - factory interface
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * Creates a new category with the provided details. Only admins can create categories.
         * @summary Create a new category
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerCreate(createCategoryDto: CreateCategoryDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.categoryControllerCreate(createCategoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all categories
         * @summary Get all categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<CategoryControllerFindAll200Response> {
            return localVarFp.categoryControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single category by its ID
         * @summary Get category by ID
         * @param {string} id Category CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CategoryControllerFindOne200Response> {
            return localVarFp.categoryControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a category. Only admins can delete categories.
         * @summary Delete category
         * @param {string} id Category CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.categoryControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing category. Only admins can update categories.
         * @summary Update category
         * @param {string} id Category CUID
         * @param {UpdateCategoryDto} updateCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerUpdate(id: string, updateCategoryDto: UpdateCategoryDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.categoryControllerUpdate(id, updateCategoryDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Creates a new category with the provided details. Only admins can create categories.
     * @summary Create a new category
     * @param {CreateCategoryDto} createCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryControllerCreate(createCategoryDto: CreateCategoryDto, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoryControllerCreate(createCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all categories
     * @summary Get all categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryControllerFindAll(options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoryControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single category by its ID
     * @summary Get category by ID
     * @param {string} id Category CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoryControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a category. Only admins can delete categories.
     * @summary Delete category
     * @param {string} id Category CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoryControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing category. Only admins can update categories.
     * @summary Update category
     * @param {string} id Category CUID
     * @param {UpdateCategoryDto} updateCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryControllerUpdate(id: string, updateCategoryDto: UpdateCategoryDto, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoryControllerUpdate(id, updateCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CheckoutApi - axios parameter creator
 */
export const CheckoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an order with pricing snapshot. Revalidates coupon, records usage, and clears cart if source is CART.
         * @summary Commit checkout and create order
         * @param {CheckoutCommitDto} checkoutCommitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutControllerCommitCheckout: async (checkoutCommitDto: CheckoutCommitDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutCommitDto' is not null or undefined
            assertParamExists('checkoutControllerCommitCheckout', 'checkoutCommitDto', checkoutCommitDto)
            const localVarPath = `/api/checkout/commit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutCommitDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pricing breakdown for checkout without committing. Validates coupon if provided. Safe to call multiple times.
         * @summary Preview checkout pricing
         * @param {CheckoutPreviewDto} checkoutPreviewDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutControllerPreviewCheckout: async (checkoutPreviewDto: CheckoutPreviewDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutPreviewDto' is not null or undefined
            assertParamExists('checkoutControllerPreviewCheckout', 'checkoutPreviewDto', checkoutPreviewDto)
            const localVarPath = `/api/checkout/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutPreviewDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutApi - functional programming interface
 */
export const CheckoutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CheckoutApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an order with pricing snapshot. Revalidates coupon, records usage, and clears cart if source is CART.
         * @summary Commit checkout and create order
         * @param {CheckoutCommitDto} checkoutCommitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkoutControllerCommitCheckout(checkoutCommitDto: CheckoutCommitDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutControllerCommitCheckout201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkoutControllerCommitCheckout(checkoutCommitDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckoutApi.checkoutControllerCommitCheckout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pricing breakdown for checkout without committing. Validates coupon if provided. Safe to call multiple times.
         * @summary Preview checkout pricing
         * @param {CheckoutPreviewDto} checkoutPreviewDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkoutControllerPreviewCheckout(checkoutPreviewDto: CheckoutPreviewDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutControllerPreviewCheckout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkoutControllerPreviewCheckout(checkoutPreviewDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckoutApi.checkoutControllerPreviewCheckout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CheckoutApi - factory interface
 */
export const CheckoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CheckoutApiFp(configuration)
    return {
        /**
         * Creates an order with pricing snapshot. Revalidates coupon, records usage, and clears cart if source is CART.
         * @summary Commit checkout and create order
         * @param {CheckoutCommitDto} checkoutCommitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutControllerCommitCheckout(checkoutCommitDto: CheckoutCommitDto, options?: RawAxiosRequestConfig): AxiosPromise<CheckoutControllerCommitCheckout201Response> {
            return localVarFp.checkoutControllerCommitCheckout(checkoutCommitDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pricing breakdown for checkout without committing. Validates coupon if provided. Safe to call multiple times.
         * @summary Preview checkout pricing
         * @param {CheckoutPreviewDto} checkoutPreviewDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutControllerPreviewCheckout(checkoutPreviewDto: CheckoutPreviewDto, options?: RawAxiosRequestConfig): AxiosPromise<CheckoutControllerPreviewCheckout200Response> {
            return localVarFp.checkoutControllerPreviewCheckout(checkoutPreviewDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CheckoutApi - object-oriented interface
 */
export class CheckoutApi extends BaseAPI {
    /**
     * Creates an order with pricing snapshot. Revalidates coupon, records usage, and clears cart if source is CART.
     * @summary Commit checkout and create order
     * @param {CheckoutCommitDto} checkoutCommitDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public checkoutControllerCommitCheckout(checkoutCommitDto: CheckoutCommitDto, options?: RawAxiosRequestConfig) {
        return CheckoutApiFp(this.configuration).checkoutControllerCommitCheckout(checkoutCommitDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pricing breakdown for checkout without committing. Validates coupon if provided. Safe to call multiple times.
     * @summary Preview checkout pricing
     * @param {CheckoutPreviewDto} checkoutPreviewDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public checkoutControllerPreviewCheckout(checkoutPreviewDto: CheckoutPreviewDto, options?: RawAxiosRequestConfig) {
        return CheckoutApiFp(this.configuration).checkoutControllerPreviewCheckout(checkoutPreviewDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CouponsApi - axios parameter creator
 */
export const CouponsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all active coupons that the user can still use based on per-user usage limits
         * @summary Get available coupons for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponControllerGetAvailableCoupons: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/coupons/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve coupon details by code
         * @summary Get coupon by code
         * @param {string} code Coupon code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponControllerGetCouponByCode: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('couponControllerGetCouponByCode', 'code', code)
            const localVarPath = `/api/coupons/code/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates if a coupon can be applied to the cart with given total. Returns discount amount if valid.
         * @summary Validate coupon for cart
         * @param {ValidateCouponDto} validateCouponDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponControllerValidateCoupon: async (validateCouponDto: ValidateCouponDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validateCouponDto' is not null or undefined
            assertParamExists('couponControllerValidateCoupon', 'validateCouponDto', validateCouponDto)
            const localVarPath = `/api/coupons/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateCouponDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CouponsApi - functional programming interface
 */
export const CouponsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CouponsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all active coupons that the user can still use based on per-user usage limits
         * @summary Get available coupons for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponControllerGetAvailableCoupons(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponControllerGetAvailableCoupons200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponControllerGetAvailableCoupons(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponsApi.couponControllerGetAvailableCoupons']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve coupon details by code
         * @summary Get coupon by code
         * @param {string} code Coupon code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponControllerGetCouponByCode(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponControllerGetCouponByCode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponControllerGetCouponByCode(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponsApi.couponControllerGetCouponByCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates if a coupon can be applied to the cart with given total. Returns discount amount if valid.
         * @summary Validate coupon for cart
         * @param {ValidateCouponDto} validateCouponDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponControllerValidateCoupon(validateCouponDto: ValidateCouponDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponControllerValidateCoupon200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponControllerValidateCoupon(validateCouponDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponsApi.couponControllerValidateCoupon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CouponsApi - factory interface
 */
export const CouponsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CouponsApiFp(configuration)
    return {
        /**
         * Returns all active coupons that the user can still use based on per-user usage limits
         * @summary Get available coupons for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponControllerGetAvailableCoupons(options?: RawAxiosRequestConfig): AxiosPromise<CouponControllerGetAvailableCoupons200Response> {
            return localVarFp.couponControllerGetAvailableCoupons(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve coupon details by code
         * @summary Get coupon by code
         * @param {string} code Coupon code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponControllerGetCouponByCode(code: string, options?: RawAxiosRequestConfig): AxiosPromise<CouponControllerGetCouponByCode200Response> {
            return localVarFp.couponControllerGetCouponByCode(code, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates if a coupon can be applied to the cart with given total. Returns discount amount if valid.
         * @summary Validate coupon for cart
         * @param {ValidateCouponDto} validateCouponDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponControllerValidateCoupon(validateCouponDto: ValidateCouponDto, options?: RawAxiosRequestConfig): AxiosPromise<CouponControllerValidateCoupon200Response> {
            return localVarFp.couponControllerValidateCoupon(validateCouponDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CouponsApi - object-oriented interface
 */
export class CouponsApi extends BaseAPI {
    /**
     * Returns all active coupons that the user can still use based on per-user usage limits
     * @summary Get available coupons for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public couponControllerGetAvailableCoupons(options?: RawAxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponControllerGetAvailableCoupons(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve coupon details by code
     * @summary Get coupon by code
     * @param {string} code Coupon code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public couponControllerGetCouponByCode(code: string, options?: RawAxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponControllerGetCouponByCode(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates if a coupon can be applied to the cart with given total. Returns discount amount if valid.
     * @summary Validate coupon for cart
     * @param {ValidateCouponDto} validateCouponDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public couponControllerValidateCoupon(validateCouponDto: ValidateCouponDto, options?: RawAxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponControllerValidateCoupon(validateCouponDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeedsApi - axios parameter creator
 */
export const FeedsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves categories with their products for feed display
         * @summary Get category product feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedControllerGetFeed: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/feed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedsApi - functional programming interface
 */
export const FeedsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves categories with their products for feed display
         * @summary Get category product feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedControllerGetFeed(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedControllerGetFeed200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedControllerGetFeed(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedsApi.feedControllerGetFeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeedsApi - factory interface
 */
export const FeedsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedsApiFp(configuration)
    return {
        /**
         * Retrieves categories with their products for feed display
         * @summary Get category product feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedControllerGetFeed(options?: RawAxiosRequestConfig): AxiosPromise<FeedControllerGetFeed200Response> {
            return localVarFp.feedControllerGetFeed(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedsApi - object-oriented interface
 */
export class FeedsApi extends BaseAPI {
    /**
     * Retrieves categories with their products for feed display
     * @summary Get category product feed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public feedControllerGetFeed(options?: RawAxiosRequestConfig) {
        return FeedsApiFp(this.configuration).feedControllerGetFeed(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OffersApi - axios parameter creator
 */
export const OffersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all currently active offers sorted by priority
         * @summary Get all active offers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerControllerGetActiveOffers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information about a specific offer
         * @summary Get offer by ID
         * @param {string} id Offer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerControllerGetOffer: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('offerControllerGetOffer', 'id', id)
            const localVarPath = `/api/offers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all active offers applicable to a specific product, sorted by priority
         * @summary Get offers for product
         * @param {string} productId Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerControllerGetProductOffers: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('offerControllerGetProductOffers', 'productId', productId)
            const localVarPath = `/api/offers/product/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OffersApi - functional programming interface
 */
export const OffersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OffersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all currently active offers sorted by priority
         * @summary Get all active offers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async offerControllerGetActiveOffers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferControllerGetActiveOffers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.offerControllerGetActiveOffers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OffersApi.offerControllerGetActiveOffers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information about a specific offer
         * @summary Get offer by ID
         * @param {string} id Offer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async offerControllerGetOffer(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferControllerGetOffer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.offerControllerGetOffer(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OffersApi.offerControllerGetOffer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all active offers applicable to a specific product, sorted by priority
         * @summary Get offers for product
         * @param {string} productId Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async offerControllerGetProductOffers(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferControllerGetActiveOffers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.offerControllerGetProductOffers(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OffersApi.offerControllerGetProductOffers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OffersApi - factory interface
 */
export const OffersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OffersApiFp(configuration)
    return {
        /**
         * Returns all currently active offers sorted by priority
         * @summary Get all active offers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerControllerGetActiveOffers(options?: RawAxiosRequestConfig): AxiosPromise<OfferControllerGetActiveOffers200Response> {
            return localVarFp.offerControllerGetActiveOffers(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information about a specific offer
         * @summary Get offer by ID
         * @param {string} id Offer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerControllerGetOffer(id: string, options?: RawAxiosRequestConfig): AxiosPromise<OfferControllerGetOffer200Response> {
            return localVarFp.offerControllerGetOffer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all active offers applicable to a specific product, sorted by priority
         * @summary Get offers for product
         * @param {string} productId Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerControllerGetProductOffers(productId: string, options?: RawAxiosRequestConfig): AxiosPromise<OfferControllerGetActiveOffers200Response> {
            return localVarFp.offerControllerGetProductOffers(productId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OffersApi - object-oriented interface
 */
export class OffersApi extends BaseAPI {
    /**
     * Returns all currently active offers sorted by priority
     * @summary Get all active offers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public offerControllerGetActiveOffers(options?: RawAxiosRequestConfig) {
        return OffersApiFp(this.configuration).offerControllerGetActiveOffers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information about a specific offer
     * @summary Get offer by ID
     * @param {string} id Offer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public offerControllerGetOffer(id: string, options?: RawAxiosRequestConfig) {
        return OffersApiFp(this.configuration).offerControllerGetOffer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all active offers applicable to a specific product, sorted by priority
     * @summary Get offers for product
     * @param {string} productId Product ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public offerControllerGetProductOffers(productId: string, options?: RawAxiosRequestConfig) {
        return OffersApiFp(this.configuration).offerControllerGetProductOffers(productId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrdersCustomerApi - axios parameter creator
 */
export const OrdersCustomerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel an order if it is still cancellable
         * @summary Cancel order
         * @param {string} id Order ID
         * @param {CancelOrderDto} cancelOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerCancelOrder: async (id: string, cancelOrderDto: CancelOrderDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('customerOrderControllerCancelOrder', 'id', id)
            // verify required parameter 'cancelOrderDto' is not null or undefined
            assertParamExists('customerOrderControllerCancelOrder', 'cancelOrderDto', cancelOrderDto)
            const localVarPath = `/api/orders/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelOrderDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all orders for the authenticated customer
         * @summary Get my orders
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerGetMyOrders: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/orders/my-orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersCustomerApi - functional programming interface
 */
export const OrdersCustomerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersCustomerApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel an order if it is still cancellable
         * @summary Cancel order
         * @param {string} id Order ID
         * @param {CancelOrderDto} cancelOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerOrderControllerCancelOrder(id: string, cancelOrderDto: CancelOrderDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerOrderControllerCancelOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerOrderControllerCancelOrder(id, cancelOrderDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersCustomerApi.customerOrderControllerCancelOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all orders for the authenticated customer
         * @summary Get my orders
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerOrderControllerGetMyOrders(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerOrderControllerGetMyOrders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerOrderControllerGetMyOrders(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersCustomerApi.customerOrderControllerGetMyOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrdersCustomerApi - factory interface
 */
export const OrdersCustomerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersCustomerApiFp(configuration)
    return {
        /**
         * Cancel an order if it is still cancellable
         * @summary Cancel order
         * @param {string} id Order ID
         * @param {CancelOrderDto} cancelOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerCancelOrder(id: string, cancelOrderDto: CancelOrderDto, options?: RawAxiosRequestConfig): AxiosPromise<CustomerOrderControllerCancelOrder200Response> {
            return localVarFp.customerOrderControllerCancelOrder(id, cancelOrderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all orders for the authenticated customer
         * @summary Get my orders
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerGetMyOrders(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<CustomerOrderControllerGetMyOrders200Response> {
            return localVarFp.customerOrderControllerGetMyOrders(page, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersCustomerApi - object-oriented interface
 */
export class OrdersCustomerApi extends BaseAPI {
    /**
     * Cancel an order if it is still cancellable
     * @summary Cancel order
     * @param {string} id Order ID
     * @param {CancelOrderDto} cancelOrderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customerOrderControllerCancelOrder(id: string, cancelOrderDto: CancelOrderDto, options?: RawAxiosRequestConfig) {
        return OrdersCustomerApiFp(this.configuration).customerOrderControllerCancelOrder(id, cancelOrderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all orders for the authenticated customer
     * @summary Get my orders
     * @param {number} [page] Page number
     * @param {number} [limit] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customerOrderControllerGetMyOrders(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return OrdersCustomerApiFp(this.configuration).customerOrderControllerGetMyOrders(page, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductVariantsApi - axios parameter creator
 */
export const ProductVariantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Makes variant available for purchase (if stock > 0).
         * @summary Activate variant
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerActivateVariant: async (variantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('variantControllerActivateVariant', 'variantId', variantId)
            const localVarPath = `/api/products/variants/{variantId}/activate`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new sellable variant for an existing product. Required to make product purchasable.
         * @summary Add variant to product
         * @param {string} productId Product UUID to add variant to
         * @param {CreateVariantDto} createVariantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerCreateVariant: async (productId: string, createVariantDto: CreateVariantDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('variantControllerCreateVariant', 'productId', productId)
            // verify required parameter 'createVariantDto' is not null or undefined
            assertParamExists('variantControllerCreateVariant', 'createVariantDto', createVariantDto)
            const localVarPath = `/api/products/{productId}/variants`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVariantDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Makes variant unavailable for purchase (temporarily).
         * @summary Deactivate variant
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerDeactivateVariant: async (variantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('variantControllerDeactivateVariant', 'variantId', variantId)
            const localVarPath = `/api/products/variants/{variantId}/deactivate`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Soft deletes a variant. Admin only.
         * @summary Delete variant (soft delete)
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerDeleteVariant: async (variantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('variantControllerDeleteVariant', 'variantId', variantId)
            const localVarPath = `/api/products/variants/{variantId}`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an image associated with a variant.
         * @summary Delete variant image
         * @param {string} variantId Variant UUID
         * @param {number} position 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerDeleteVariantImage: async (variantId: string, position: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('variantControllerDeleteVariantImage', 'variantId', variantId)
            // verify required parameter 'position' is not null or undefined
            assertParamExists('variantControllerDeleteVariantImage', 'position', position)
            const localVarPath = `/api/products/variants/{variantId}/images/{position}`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)))
                .replace(`{${"position"}}`, encodeURIComponent(String(position)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information about a specific variant.
         * @summary Get variant by ID
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerGetVariant: async (variantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('variantControllerGetVariant', 'variantId', variantId)
            const localVarPath = `/api/products/variants/{variantId}`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all variants (sizes, types) available for a product.
         * @summary List all variants for a product
         * @param {string} productId Product CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerGetVariantsByProduct: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('variantControllerGetVariantsByProduct', 'productId', productId)
            const localVarPath = `/api/products/{productId}/variants`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the uploaded image information to the variant.
         * @summary Save variant image
         * @param {string} variantId Variant UUID
         * @param {SaveVariantImageDto} saveVariantImageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerSaveVariantImage: async (variantId: string, saveVariantImageDto: SaveVariantImageDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('variantControllerSaveVariantImage', 'variantId', variantId)
            // verify required parameter 'saveVariantImageDto' is not null or undefined
            assertParamExists('variantControllerSaveVariantImage', 'saveVariantImageDto', saveVariantImageDto)
            const localVarPath = `/api/products/variants/{variantId}/images/save`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveVariantImageDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dedicated endpoint for stock management. Supports set, add, and reduce operations.
         * @summary Update variant stock
         * @param {string} variantId Variant UUID
         * @param {UpdateVariantStockDto} updateVariantStockDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerUpdateStock: async (variantId: string, updateVariantStockDto: UpdateVariantStockDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('variantControllerUpdateStock', 'variantId', variantId)
            // verify required parameter 'updateVariantStockDto' is not null or undefined
            assertParamExists('variantControllerUpdateStock', 'updateVariantStockDto', updateVariantStockDto)
            const localVarPath = `/api/products/variants/{variantId}/stock`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVariantStockDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates commerce attributes of a variant (price, stock, discount, etc.). Use dedicated endpoints for specific operations.
         * @summary Update variant details
         * @param {string} variantId Variant UUID
         * @param {UpdateVariantDto} updateVariantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerUpdateVariant: async (variantId: string, updateVariantDto: UpdateVariantDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('variantControllerUpdateVariant', 'variantId', variantId)
            // verify required parameter 'updateVariantDto' is not null or undefined
            assertParamExists('variantControllerUpdateVariant', 'updateVariantDto', updateVariantDto)
            const localVarPath = `/api/products/variants/{variantId}`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVariantDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads an image for a variant and associates it.
         * @summary Upload variant image
         * @param {string} variantId Variant CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerUploadVariantImage: async (variantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('variantControllerUploadVariantImage', 'variantId', variantId)
            const localVarPath = `/api/products/variants/{variantId}/images`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductVariantsApi - functional programming interface
 */
export const ProductVariantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductVariantsApiAxiosParamCreator(configuration)
    return {
        /**
         * Makes variant available for purchase (if stock > 0).
         * @summary Activate variant
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerActivateVariant(variantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerActivateVariant(variantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerActivateVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new sellable variant for an existing product. Required to make product purchasable.
         * @summary Add variant to product
         * @param {string} productId Product UUID to add variant to
         * @param {CreateVariantDto} createVariantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerCreateVariant(productId: string, createVariantDto: CreateVariantDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantControllerCreateVariant201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerCreateVariant(productId, createVariantDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerCreateVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Makes variant unavailable for purchase (temporarily).
         * @summary Deactivate variant
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerDeactivateVariant(variantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerDeactivateVariant(variantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerDeactivateVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Soft deletes a variant. Admin only.
         * @summary Delete variant (soft delete)
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerDeleteVariant(variantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerDeleteVariant(variantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerDeleteVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an image associated with a variant.
         * @summary Delete variant image
         * @param {string} variantId Variant UUID
         * @param {number} position 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerDeleteVariantImage(variantId: string, position: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerDeleteVariantImage(variantId, position, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerDeleteVariantImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information about a specific variant.
         * @summary Get variant by ID
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerGetVariant(variantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantControllerCreateVariant201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerGetVariant(variantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerGetVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all variants (sizes, types) available for a product.
         * @summary List all variants for a product
         * @param {string} productId Product CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerGetVariantsByProduct(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantControllerGetVariantsByProduct200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerGetVariantsByProduct(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerGetVariantsByProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the uploaded image information to the variant.
         * @summary Save variant image
         * @param {string} variantId Variant UUID
         * @param {SaveVariantImageDto} saveVariantImageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerSaveVariantImage(variantId: string, saveVariantImageDto: SaveVariantImageDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerSaveVariantImage(variantId, saveVariantImageDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerSaveVariantImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dedicated endpoint for stock management. Supports set, add, and reduce operations.
         * @summary Update variant stock
         * @param {string} variantId Variant UUID
         * @param {UpdateVariantStockDto} updateVariantStockDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerUpdateStock(variantId: string, updateVariantStockDto: UpdateVariantStockDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerUpdateStock(variantId, updateVariantStockDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerUpdateStock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates commerce attributes of a variant (price, stock, discount, etc.). Use dedicated endpoints for specific operations.
         * @summary Update variant details
         * @param {string} variantId Variant UUID
         * @param {UpdateVariantDto} updateVariantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerUpdateVariant(variantId: string, updateVariantDto: UpdateVariantDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerUpdateVariant(variantId, updateVariantDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerUpdateVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads an image for a variant and associates it.
         * @summary Upload variant image
         * @param {string} variantId Variant CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerUploadVariantImage(variantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantControllerUploadVariantImage201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerUploadVariantImage(variantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerUploadVariantImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductVariantsApi - factory interface
 */
export const ProductVariantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductVariantsApiFp(configuration)
    return {
        /**
         * Makes variant available for purchase (if stock > 0).
         * @summary Activate variant
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerActivateVariant(variantId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.variantControllerActivateVariant(variantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new sellable variant for an existing product. Required to make product purchasable.
         * @summary Add variant to product
         * @param {string} productId Product UUID to add variant to
         * @param {CreateVariantDto} createVariantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerCreateVariant(productId: string, createVariantDto: CreateVariantDto, options?: RawAxiosRequestConfig): AxiosPromise<VariantControllerCreateVariant201Response> {
            return localVarFp.variantControllerCreateVariant(productId, createVariantDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Makes variant unavailable for purchase (temporarily).
         * @summary Deactivate variant
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerDeactivateVariant(variantId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.variantControllerDeactivateVariant(variantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Soft deletes a variant. Admin only.
         * @summary Delete variant (soft delete)
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerDeleteVariant(variantId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.variantControllerDeleteVariant(variantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an image associated with a variant.
         * @summary Delete variant image
         * @param {string} variantId Variant UUID
         * @param {number} position 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerDeleteVariantImage(variantId: string, position: number, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.variantControllerDeleteVariantImage(variantId, position, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about a specific variant.
         * @summary Get variant by ID
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerGetVariant(variantId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantControllerCreateVariant201Response> {
            return localVarFp.variantControllerGetVariant(variantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all variants (sizes, types) available for a product.
         * @summary List all variants for a product
         * @param {string} productId Product CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerGetVariantsByProduct(productId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantControllerGetVariantsByProduct200Response> {
            return localVarFp.variantControllerGetVariantsByProduct(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the uploaded image information to the variant.
         * @summary Save variant image
         * @param {string} variantId Variant UUID
         * @param {SaveVariantImageDto} saveVariantImageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerSaveVariantImage(variantId: string, saveVariantImageDto: SaveVariantImageDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.variantControllerSaveVariantImage(variantId, saveVariantImageDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Dedicated endpoint for stock management. Supports set, add, and reduce operations.
         * @summary Update variant stock
         * @param {string} variantId Variant UUID
         * @param {UpdateVariantStockDto} updateVariantStockDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerUpdateStock(variantId: string, updateVariantStockDto: UpdateVariantStockDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.variantControllerUpdateStock(variantId, updateVariantStockDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates commerce attributes of a variant (price, stock, discount, etc.). Use dedicated endpoints for specific operations.
         * @summary Update variant details
         * @param {string} variantId Variant UUID
         * @param {UpdateVariantDto} updateVariantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerUpdateVariant(variantId: string, updateVariantDto: UpdateVariantDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.variantControllerUpdateVariant(variantId, updateVariantDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads an image for a variant and associates it.
         * @summary Upload variant image
         * @param {string} variantId Variant CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerUploadVariantImage(variantId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantControllerUploadVariantImage201Response> {
            return localVarFp.variantControllerUploadVariantImage(variantId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductVariantsApi - object-oriented interface
 */
export class ProductVariantsApi extends BaseAPI {
    /**
     * Makes variant available for purchase (if stock > 0).
     * @summary Activate variant
     * @param {string} variantId Variant UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerActivateVariant(variantId: string, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerActivateVariant(variantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new sellable variant for an existing product. Required to make product purchasable.
     * @summary Add variant to product
     * @param {string} productId Product UUID to add variant to
     * @param {CreateVariantDto} createVariantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerCreateVariant(productId: string, createVariantDto: CreateVariantDto, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerCreateVariant(productId, createVariantDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Makes variant unavailable for purchase (temporarily).
     * @summary Deactivate variant
     * @param {string} variantId Variant UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerDeactivateVariant(variantId: string, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerDeactivateVariant(variantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Soft deletes a variant. Admin only.
     * @summary Delete variant (soft delete)
     * @param {string} variantId Variant UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerDeleteVariant(variantId: string, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerDeleteVariant(variantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an image associated with a variant.
     * @summary Delete variant image
     * @param {string} variantId Variant UUID
     * @param {number} position 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerDeleteVariantImage(variantId: string, position: number, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerDeleteVariantImage(variantId, position, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information about a specific variant.
     * @summary Get variant by ID
     * @param {string} variantId Variant UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerGetVariant(variantId: string, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerGetVariant(variantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all variants (sizes, types) available for a product.
     * @summary List all variants for a product
     * @param {string} productId Product CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerGetVariantsByProduct(productId: string, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerGetVariantsByProduct(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the uploaded image information to the variant.
     * @summary Save variant image
     * @param {string} variantId Variant UUID
     * @param {SaveVariantImageDto} saveVariantImageDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerSaveVariantImage(variantId: string, saveVariantImageDto: SaveVariantImageDto, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerSaveVariantImage(variantId, saveVariantImageDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dedicated endpoint for stock management. Supports set, add, and reduce operations.
     * @summary Update variant stock
     * @param {string} variantId Variant UUID
     * @param {UpdateVariantStockDto} updateVariantStockDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerUpdateStock(variantId: string, updateVariantStockDto: UpdateVariantStockDto, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerUpdateStock(variantId, updateVariantStockDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates commerce attributes of a variant (price, stock, discount, etc.). Use dedicated endpoints for specific operations.
     * @summary Update variant details
     * @param {string} variantId Variant UUID
     * @param {UpdateVariantDto} updateVariantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerUpdateVariant(variantId: string, updateVariantDto: UpdateVariantDto, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerUpdateVariant(variantId, updateVariantDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads an image for a variant and associates it.
     * @summary Upload variant image
     * @param {string} variantId Variant CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerUploadVariantImage(variantId: string, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerUploadVariantImage(variantId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductsApi - axios parameter creator
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates catalog information only. Does NOT affect pricing or stock.
         * @summary Update product information
         * @param {string} id Product UUID
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerUpdate: async (id: string, updateProductDto: UpdateProductDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productControllerUpdate', 'id', id)
            // verify required parameter 'updateProductDto' is not null or undefined
            assertParamExists('productControllerUpdate', 'updateProductDto', updateProductDto)
            const localVarPath = `/api/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Updates catalog information only. Does NOT affect pricing or stock.
         * @summary Update product information
         * @param {string} id Product UUID
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductControllerUpdate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerUpdate(id, updateProductDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.productControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductsApi - factory interface
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * Updates catalog information only. Does NOT affect pricing or stock.
         * @summary Update product information
         * @param {string} id Product UUID
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig): AxiosPromise<ProductControllerUpdate200Response> {
            return localVarFp.productControllerUpdate(id, updateProductDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 */
export class ProductsApi extends BaseAPI {
    /**
     * Updates catalog information only. Does NOT affect pricing or stock.
     * @summary Update product information
     * @param {string} id Product UUID
     * @param {UpdateProductDto} updateProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productControllerUpdate(id, updateProductDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductsAdminApi - axios parameter creator
 */
export const ProductsAdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Admin permanently discontinues a product. ONE-WAY operation.
         * @summary Discontinue product (permanent)
         * @param {string} id Product CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductControllerDiscontinueProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminProductControllerDiscontinueProduct', 'id', id)
            const localVarPath = `/api/admin/products/{id}/discontinue`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all products with all statuses for admin governance.
         * @summary Get all products (admin)
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term for product name or description
         * @param {string} [categoryId] Filter by category ID
         * @param {string} [status] Filter by product status
         * @param {AdminProductControllerGetAdminProductsSortByEnum} [sortBy] Sort by field
         * @param {AdminProductControllerGetAdminProductsSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductControllerGetAdminProducts: async (page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: AdminProductControllerGetAdminProductsSortByEnum, sortOrder?: AdminProductControllerGetAdminProductsSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin changes product status for governance.
         * @summary Update product status
         * @param {string} id Product CUID
         * @param {UpdateProductStatusDto} updateProductStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductControllerUpdateProductStatus: async (id: string, updateProductStatusDto: UpdateProductStatusDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminProductControllerUpdateProductStatus', 'id', id)
            // verify required parameter 'updateProductStatusDto' is not null or undefined
            assertParamExists('adminProductControllerUpdateProductStatus', 'updateProductStatusDto', updateProductStatusDto)
            const localVarPath = `/api/admin/products/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsAdminApi - functional programming interface
 */
export const ProductsAdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsAdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Admin permanently discontinues a product. ONE-WAY operation.
         * @summary Discontinue product (permanent)
         * @param {string} id Product CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminProductControllerDiscontinueProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminProductControllerDiscontinueProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsAdminApi.adminProductControllerDiscontinueProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all products with all statuses for admin governance.
         * @summary Get all products (admin)
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term for product name or description
         * @param {string} [categoryId] Filter by category ID
         * @param {string} [status] Filter by product status
         * @param {AdminProductControllerGetAdminProductsSortByEnum} [sortBy] Sort by field
         * @param {AdminProductControllerGetAdminProductsSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminProductControllerGetAdminProducts(page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: AdminProductControllerGetAdminProductsSortByEnum, sortOrder?: AdminProductControllerGetAdminProductsSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminProductControllerGetAdminProducts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminProductControllerGetAdminProducts(page, limit, search, categoryId, status, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsAdminApi.adminProductControllerGetAdminProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admin changes product status for governance.
         * @summary Update product status
         * @param {string} id Product CUID
         * @param {UpdateProductStatusDto} updateProductStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminProductControllerUpdateProductStatus(id: string, updateProductStatusDto: UpdateProductStatusDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminProductControllerUpdateProductStatus(id, updateProductStatusDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsAdminApi.adminProductControllerUpdateProductStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductsAdminApi - factory interface
 */
export const ProductsAdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsAdminApiFp(configuration)
    return {
        /**
         * Admin permanently discontinues a product. ONE-WAY operation.
         * @summary Discontinue product (permanent)
         * @param {string} id Product CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductControllerDiscontinueProduct(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.adminProductControllerDiscontinueProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all products with all statuses for admin governance.
         * @summary Get all products (admin)
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term for product name or description
         * @param {string} [categoryId] Filter by category ID
         * @param {string} [status] Filter by product status
         * @param {AdminProductControllerGetAdminProductsSortByEnum} [sortBy] Sort by field
         * @param {AdminProductControllerGetAdminProductsSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductControllerGetAdminProducts(page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: AdminProductControllerGetAdminProductsSortByEnum, sortOrder?: AdminProductControllerGetAdminProductsSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<AdminProductControllerGetAdminProducts200Response> {
            return localVarFp.adminProductControllerGetAdminProducts(page, limit, search, categoryId, status, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Admin changes product status for governance.
         * @summary Update product status
         * @param {string} id Product CUID
         * @param {UpdateProductStatusDto} updateProductStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductControllerUpdateProductStatus(id: string, updateProductStatusDto: UpdateProductStatusDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.adminProductControllerUpdateProductStatus(id, updateProductStatusDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsAdminApi - object-oriented interface
 */
export class ProductsAdminApi extends BaseAPI {
    /**
     * Admin permanently discontinues a product. ONE-WAY operation.
     * @summary Discontinue product (permanent)
     * @param {string} id Product CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminProductControllerDiscontinueProduct(id: string, options?: RawAxiosRequestConfig) {
        return ProductsAdminApiFp(this.configuration).adminProductControllerDiscontinueProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all products with all statuses for admin governance.
     * @summary Get all products (admin)
     * @param {number} [page] Page number
     * @param {number} [limit] Number of items per page
     * @param {string} [search] Search term for product name or description
     * @param {string} [categoryId] Filter by category ID
     * @param {string} [status] Filter by product status
     * @param {AdminProductControllerGetAdminProductsSortByEnum} [sortBy] Sort by field
     * @param {AdminProductControllerGetAdminProductsSortOrderEnum} [sortOrder] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminProductControllerGetAdminProducts(page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: AdminProductControllerGetAdminProductsSortByEnum, sortOrder?: AdminProductControllerGetAdminProductsSortOrderEnum, options?: RawAxiosRequestConfig) {
        return ProductsAdminApiFp(this.configuration).adminProductControllerGetAdminProducts(page, limit, search, categoryId, status, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admin changes product status for governance.
     * @summary Update product status
     * @param {string} id Product CUID
     * @param {UpdateProductStatusDto} updateProductStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminProductControllerUpdateProductStatus(id: string, updateProductStatusDto: UpdateProductStatusDto, options?: RawAxiosRequestConfig) {
        return ProductsAdminApiFp(this.configuration).adminProductControllerUpdateProductStatus(id, updateProductStatusDto, options).then((request) => request(this.axios, this.basePath));
    }
}

export const AdminProductControllerGetAdminProductsSortByEnum = {
    Name: 'name',
    Price: 'price',
    CreatedAt: 'createdAt'
} as const;
export type AdminProductControllerGetAdminProductsSortByEnum = typeof AdminProductControllerGetAdminProductsSortByEnum[keyof typeof AdminProductControllerGetAdminProductsSortByEnum];
export const AdminProductControllerGetAdminProductsSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AdminProductControllerGetAdminProductsSortOrderEnum = typeof AdminProductControllerGetAdminProductsSortOrderEnum[keyof typeof AdminProductControllerGetAdminProductsSortOrderEnum];


/**
 * ProductsPublicApi - axios parameter creator
 */
export const ProductsPublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves paginated list of ACTIVE products with first variant and category. Perfect for homepage/listing pages. Public endpoint.
         * @summary Browse marketplace products with preview
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term for product name or description
         * @param {string} [categoryId] Filter by category ID
         * @param {string} [status] Filter by product status
         * @param {ProductPublicControllerFindAllSortByEnum} [sortBy] Sort by field
         * @param {ProductPublicControllerFindAllSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productPublicControllerFindAll: async (page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: ProductPublicControllerFindAllSortByEnum, sortOrder?: ProductPublicControllerFindAllSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single product by ID with category populated. Public endpoint.
         * @summary Get product details with category
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productPublicControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productPublicControllerFindOne', 'id', id)
            const localVarPath = `/api/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves complete product details with category and all variants with images. Perfect for product detail pages. Public endpoint.
         * @summary Get product with all variants and category
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productPublicControllerGetProductWithVariants: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productPublicControllerGetProductWithVariants', 'id', id)
            const localVarPath = `/api/products/{id}/with-variants`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsPublicApi - functional programming interface
 */
export const ProductsPublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsPublicApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves paginated list of ACTIVE products with first variant and category. Perfect for homepage/listing pages. Public endpoint.
         * @summary Browse marketplace products with preview
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term for product name or description
         * @param {string} [categoryId] Filter by category ID
         * @param {string} [status] Filter by product status
         * @param {ProductPublicControllerFindAllSortByEnum} [sortBy] Sort by field
         * @param {ProductPublicControllerFindAllSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productPublicControllerFindAll(page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: ProductPublicControllerFindAllSortByEnum, sortOrder?: ProductPublicControllerFindAllSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductPublicControllerFindAll200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productPublicControllerFindAll(page, limit, search, categoryId, status, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsPublicApi.productPublicControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single product by ID with category populated. Public endpoint.
         * @summary Get product details with category
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productPublicControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductPublicControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productPublicControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsPublicApi.productPublicControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves complete product details with category and all variants with images. Perfect for product detail pages. Public endpoint.
         * @summary Get product with all variants and category
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productPublicControllerGetProductWithVariants(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductPublicControllerGetProductWithVariants200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productPublicControllerGetProductWithVariants(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsPublicApi.productPublicControllerGetProductWithVariants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductsPublicApi - factory interface
 */
export const ProductsPublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsPublicApiFp(configuration)
    return {
        /**
         * Retrieves paginated list of ACTIVE products with first variant and category. Perfect for homepage/listing pages. Public endpoint.
         * @summary Browse marketplace products with preview
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term for product name or description
         * @param {string} [categoryId] Filter by category ID
         * @param {string} [status] Filter by product status
         * @param {ProductPublicControllerFindAllSortByEnum} [sortBy] Sort by field
         * @param {ProductPublicControllerFindAllSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productPublicControllerFindAll(page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: ProductPublicControllerFindAllSortByEnum, sortOrder?: ProductPublicControllerFindAllSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<ProductPublicControllerFindAll200Response> {
            return localVarFp.productPublicControllerFindAll(page, limit, search, categoryId, status, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single product by ID with category populated. Public endpoint.
         * @summary Get product details with category
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productPublicControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductPublicControllerFindOne200Response> {
            return localVarFp.productPublicControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves complete product details with category and all variants with images. Perfect for product detail pages. Public endpoint.
         * @summary Get product with all variants and category
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productPublicControllerGetProductWithVariants(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductPublicControllerGetProductWithVariants200Response> {
            return localVarFp.productPublicControllerGetProductWithVariants(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsPublicApi - object-oriented interface
 */
export class ProductsPublicApi extends BaseAPI {
    /**
     * Retrieves paginated list of ACTIVE products with first variant and category. Perfect for homepage/listing pages. Public endpoint.
     * @summary Browse marketplace products with preview
     * @param {number} [page] Page number
     * @param {number} [limit] Number of items per page
     * @param {string} [search] Search term for product name or description
     * @param {string} [categoryId] Filter by category ID
     * @param {string} [status] Filter by product status
     * @param {ProductPublicControllerFindAllSortByEnum} [sortBy] Sort by field
     * @param {ProductPublicControllerFindAllSortOrderEnum} [sortOrder] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productPublicControllerFindAll(page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: ProductPublicControllerFindAllSortByEnum, sortOrder?: ProductPublicControllerFindAllSortOrderEnum, options?: RawAxiosRequestConfig) {
        return ProductsPublicApiFp(this.configuration).productPublicControllerFindAll(page, limit, search, categoryId, status, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single product by ID with category populated. Public endpoint.
     * @summary Get product details with category
     * @param {string} id Product UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productPublicControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return ProductsPublicApiFp(this.configuration).productPublicControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves complete product details with category and all variants with images. Perfect for product detail pages. Public endpoint.
     * @summary Get product with all variants and category
     * @param {string} id Product UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productPublicControllerGetProductWithVariants(id: string, options?: RawAxiosRequestConfig) {
        return ProductsPublicApiFp(this.configuration).productPublicControllerGetProductWithVariants(id, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ProductPublicControllerFindAllSortByEnum = {
    Name: 'name',
    Price: 'price',
    CreatedAt: 'createdAt'
} as const;
export type ProductPublicControllerFindAllSortByEnum = typeof ProductPublicControllerFindAllSortByEnum[keyof typeof ProductPublicControllerFindAllSortByEnum];
export const ProductPublicControllerFindAllSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ProductPublicControllerFindAllSortOrderEnum = typeof ProductPublicControllerFindAllSortOrderEnum[keyof typeof ProductPublicControllerFindAllSortOrderEnum];


/**
 * ProductsSellerApi - axios parameter creator
 */
export const ProductsSellerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Seller activates their product to make it visible in marketplace.
         * @summary Activate product
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerProductControllerActivateProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sellerProductControllerActivateProduct', 'id', id)
            const localVarPath = `/api/seller/products/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Seller creates a new product catalog entry.
         * @summary Create new product
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerProductControllerCreate: async (createProductDto: CreateProductDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProductDto' is not null or undefined
            assertParamExists('sellerProductControllerCreate', 'createProductDto', createProductDto)
            const localVarPath = `/api/seller/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Seller deactivates their product to hide it from marketplace.
         * @summary Deactivate product
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerProductControllerDeactivateProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sellerProductControllerDeactivateProduct', 'id', id)
            const localVarPath = `/api/seller/products/{id}/deactivate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all products owned by the seller. Shows all statuses.
         * @summary Get seller products
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term for product name or description
         * @param {string} [categoryId] Filter by category ID
         * @param {string} [status] Filter by product status
         * @param {SellerProductControllerGetSellerProductsSortByEnum} [sortBy] Sort by field
         * @param {SellerProductControllerGetSellerProductsSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerProductControllerGetSellerProducts: async (page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: SellerProductControllerGetSellerProductsSortByEnum, sortOrder?: SellerProductControllerGetSellerProductsSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/seller/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Seller updates their own product information.
         * @summary Update product
         * @param {string} id Product UUID
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerProductControllerUpdate: async (id: string, updateProductDto: UpdateProductDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sellerProductControllerUpdate', 'id', id)
            // verify required parameter 'updateProductDto' is not null or undefined
            assertParamExists('sellerProductControllerUpdate', 'updateProductDto', updateProductDto)
            const localVarPath = `/api/seller/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsSellerApi - functional programming interface
 */
export const ProductsSellerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsSellerApiAxiosParamCreator(configuration)
    return {
        /**
         * Seller activates their product to make it visible in marketplace.
         * @summary Activate product
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellerProductControllerActivateProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellerProductControllerActivateProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsSellerApi.sellerProductControllerActivateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Seller creates a new product catalog entry.
         * @summary Create new product
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellerProductControllerCreate(createProductDto: CreateProductDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductControllerUpdate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellerProductControllerCreate(createProductDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsSellerApi.sellerProductControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Seller deactivates their product to hide it from marketplace.
         * @summary Deactivate product
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellerProductControllerDeactivateProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellerProductControllerDeactivateProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsSellerApi.sellerProductControllerDeactivateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all products owned by the seller. Shows all statuses.
         * @summary Get seller products
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term for product name or description
         * @param {string} [categoryId] Filter by category ID
         * @param {string} [status] Filter by product status
         * @param {SellerProductControllerGetSellerProductsSortByEnum} [sortBy] Sort by field
         * @param {SellerProductControllerGetSellerProductsSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellerProductControllerGetSellerProducts(page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: SellerProductControllerGetSellerProductsSortByEnum, sortOrder?: SellerProductControllerGetSellerProductsSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SellerProductControllerGetSellerProducts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellerProductControllerGetSellerProducts(page, limit, search, categoryId, status, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsSellerApi.sellerProductControllerGetSellerProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Seller updates their own product information.
         * @summary Update product
         * @param {string} id Product UUID
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellerProductControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductControllerUpdate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellerProductControllerUpdate(id, updateProductDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsSellerApi.sellerProductControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductsSellerApi - factory interface
 */
export const ProductsSellerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsSellerApiFp(configuration)
    return {
        /**
         * Seller activates their product to make it visible in marketplace.
         * @summary Activate product
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerProductControllerActivateProduct(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.sellerProductControllerActivateProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Seller creates a new product catalog entry.
         * @summary Create new product
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerProductControllerCreate(createProductDto: CreateProductDto, options?: RawAxiosRequestConfig): AxiosPromise<ProductControllerUpdate200Response> {
            return localVarFp.sellerProductControllerCreate(createProductDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Seller deactivates their product to hide it from marketplace.
         * @summary Deactivate product
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerProductControllerDeactivateProduct(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.sellerProductControllerDeactivateProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all products owned by the seller. Shows all statuses.
         * @summary Get seller products
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term for product name or description
         * @param {string} [categoryId] Filter by category ID
         * @param {string} [status] Filter by product status
         * @param {SellerProductControllerGetSellerProductsSortByEnum} [sortBy] Sort by field
         * @param {SellerProductControllerGetSellerProductsSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerProductControllerGetSellerProducts(page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: SellerProductControllerGetSellerProductsSortByEnum, sortOrder?: SellerProductControllerGetSellerProductsSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<SellerProductControllerGetSellerProducts200Response> {
            return localVarFp.sellerProductControllerGetSellerProducts(page, limit, search, categoryId, status, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Seller updates their own product information.
         * @summary Update product
         * @param {string} id Product UUID
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerProductControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig): AxiosPromise<ProductControllerUpdate200Response> {
            return localVarFp.sellerProductControllerUpdate(id, updateProductDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsSellerApi - object-oriented interface
 */
export class ProductsSellerApi extends BaseAPI {
    /**
     * Seller activates their product to make it visible in marketplace.
     * @summary Activate product
     * @param {string} id Product UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sellerProductControllerActivateProduct(id: string, options?: RawAxiosRequestConfig) {
        return ProductsSellerApiFp(this.configuration).sellerProductControllerActivateProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Seller creates a new product catalog entry.
     * @summary Create new product
     * @param {CreateProductDto} createProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sellerProductControllerCreate(createProductDto: CreateProductDto, options?: RawAxiosRequestConfig) {
        return ProductsSellerApiFp(this.configuration).sellerProductControllerCreate(createProductDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Seller deactivates their product to hide it from marketplace.
     * @summary Deactivate product
     * @param {string} id Product UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sellerProductControllerDeactivateProduct(id: string, options?: RawAxiosRequestConfig) {
        return ProductsSellerApiFp(this.configuration).sellerProductControllerDeactivateProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all products owned by the seller. Shows all statuses.
     * @summary Get seller products
     * @param {number} [page] Page number
     * @param {number} [limit] Number of items per page
     * @param {string} [search] Search term for product name or description
     * @param {string} [categoryId] Filter by category ID
     * @param {string} [status] Filter by product status
     * @param {SellerProductControllerGetSellerProductsSortByEnum} [sortBy] Sort by field
     * @param {SellerProductControllerGetSellerProductsSortOrderEnum} [sortOrder] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sellerProductControllerGetSellerProducts(page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: SellerProductControllerGetSellerProductsSortByEnum, sortOrder?: SellerProductControllerGetSellerProductsSortOrderEnum, options?: RawAxiosRequestConfig) {
        return ProductsSellerApiFp(this.configuration).sellerProductControllerGetSellerProducts(page, limit, search, categoryId, status, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Seller updates their own product information.
     * @summary Update product
     * @param {string} id Product UUID
     * @param {UpdateProductDto} updateProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sellerProductControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig) {
        return ProductsSellerApiFp(this.configuration).sellerProductControllerUpdate(id, updateProductDto, options).then((request) => request(this.axios, this.basePath));
    }
}

export const SellerProductControllerGetSellerProductsSortByEnum = {
    Name: 'name',
    Price: 'price',
    CreatedAt: 'createdAt'
} as const;
export type SellerProductControllerGetSellerProductsSortByEnum = typeof SellerProductControllerGetSellerProductsSortByEnum[keyof typeof SellerProductControllerGetSellerProductsSortByEnum];
export const SellerProductControllerGetSellerProductsSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type SellerProductControllerGetSellerProductsSortOrderEnum = typeof SellerProductControllerGetSellerProductsSortOrderEnum[keyof typeof SellerProductControllerGetSellerProductsSortOrderEnum];


/**
 * SellerOrdersApi - axios parameter creator
 */
export const SellerOrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve detailed information about a specific order (if it contains seller products)
         * @summary Get order by ID
         * @param {string} id Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerOrderControllerGetOrderById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sellerOrderControllerGetOrderById', 'id', id)
            const localVarPath = `/api/seller/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve orders that contain products sold by this seller
         * @summary Get orders containing my products
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerOrderControllerGetSellerOrders: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/seller/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SellerOrdersApi - functional programming interface
 */
export const SellerOrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SellerOrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve detailed information about a specific order (if it contains seller products)
         * @summary Get order by ID
         * @param {string} id Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellerOrderControllerGetOrderById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerOrderControllerCancelOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellerOrderControllerGetOrderById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SellerOrdersApi.sellerOrderControllerGetOrderById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve orders that contain products sold by this seller
         * @summary Get orders containing my products
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellerOrderControllerGetSellerOrders(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerOrderControllerGetMyOrders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellerOrderControllerGetSellerOrders(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SellerOrdersApi.sellerOrderControllerGetSellerOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SellerOrdersApi - factory interface
 */
export const SellerOrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SellerOrdersApiFp(configuration)
    return {
        /**
         * Retrieve detailed information about a specific order (if it contains seller products)
         * @summary Get order by ID
         * @param {string} id Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerOrderControllerGetOrderById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomerOrderControllerCancelOrder200Response> {
            return localVarFp.sellerOrderControllerGetOrderById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve orders that contain products sold by this seller
         * @summary Get orders containing my products
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerOrderControllerGetSellerOrders(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<CustomerOrderControllerGetMyOrders200Response> {
            return localVarFp.sellerOrderControllerGetSellerOrders(page, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SellerOrdersApi - object-oriented interface
 */
export class SellerOrdersApi extends BaseAPI {
    /**
     * Retrieve detailed information about a specific order (if it contains seller products)
     * @summary Get order by ID
     * @param {string} id Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sellerOrderControllerGetOrderById(id: string, options?: RawAxiosRequestConfig) {
        return SellerOrdersApiFp(this.configuration).sellerOrderControllerGetOrderById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve orders that contain products sold by this seller
     * @summary Get orders containing my products
     * @param {number} [page] Page number
     * @param {number} [limit] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sellerOrderControllerGetSellerOrders(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return SellerOrdersApiFp(this.configuration).sellerOrderControllerGetSellerOrders(page, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves all users with pagination. Admin only.
         * @summary Get all users
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {string} [search] Search term
         * @param {UserControllerFindAllStatusEnum} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll: async (page?: number, limit?: number, search?: string, status?: UserControllerFindAllStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single user by ID. Admin only.
         * @summary Get user by ID
         * @param {string} id User CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerFindOne', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the authenticated user profile
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the authenticated user profile
         * @summary Update current user
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate: async (updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('userControllerUpdate', 'updateUserDto', updateUserDto)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates user account status. Admin only.
         * @summary Update user status
         * @param {string} id User CUID
         * @param {UpdateUserStatusDto} updateUserStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateStatus: async (id: string, updateUserStatusDto: UpdateUserStatusDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerUpdateStatus', 'id', id)
            // verify required parameter 'updateUserStatusDto' is not null or undefined
            assertParamExists('userControllerUpdateStatus', 'updateUserStatusDto', updateUserStatusDto)
            const localVarPath = `/api/users/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves all users with pagination. Admin only.
         * @summary Get all users
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {string} [search] Search term
         * @param {UserControllerFindAllStatusEnum} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindAll(page?: number, limit?: number, search?: string, status?: UserControllerFindAllStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerFindAll200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindAll(page, limit, search, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single user by ID. Admin only.
         * @summary Get user by ID
         * @param {string} id User CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerUpdate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the authenticated user profile
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetMe200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the authenticated user profile
         * @summary Update current user
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdate(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerUpdate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdate(updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates user account status. Admin only.
         * @summary Update user status
         * @param {string} id User CUID
         * @param {UpdateUserStatusDto} updateUserStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdateStatus(id: string, updateUserStatusDto: UpdateUserStatusDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerUpdate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdateStatus(id, updateUserStatusDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdateStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Retrieves all users with pagination. Admin only.
         * @summary Get all users
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {string} [search] Search term
         * @param {UserControllerFindAllStatusEnum} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll(page?: number, limit?: number, search?: string, status?: UserControllerFindAllStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<UserControllerFindAll200Response> {
            return localVarFp.userControllerFindAll(page, limit, search, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single user by ID. Admin only.
         * @summary Get user by ID
         * @param {string} id User CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<UserControllerUpdate200Response> {
            return localVarFp.userControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the authenticated user profile
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMe(options?: RawAxiosRequestConfig): AxiosPromise<UserControllerGetMe200Response> {
            return localVarFp.userControllerGetMe(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the authenticated user profile
         * @summary Update current user
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserControllerUpdate200Response> {
            return localVarFp.userControllerUpdate(updateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates user account status. Admin only.
         * @summary Update user status
         * @param {string} id User CUID
         * @param {UpdateUserStatusDto} updateUserStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateStatus(id: string, updateUserStatusDto: UpdateUserStatusDto, options?: RawAxiosRequestConfig): AxiosPromise<UserControllerUpdate200Response> {
            return localVarFp.userControllerUpdateStatus(id, updateUserStatusDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * Retrieves all users with pagination. Admin only.
     * @summary Get all users
     * @param {number} [page] Page number
     * @param {number} [limit] Items per page
     * @param {string} [search] Search term
     * @param {UserControllerFindAllStatusEnum} [status] Filter by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerFindAll(page?: number, limit?: number, search?: string, status?: UserControllerFindAllStatusEnum, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindAll(page, limit, search, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single user by ID. Admin only.
     * @summary Get user by ID
     * @param {string} id User CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the authenticated user profile
     * @summary Get current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerGetMe(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the authenticated user profile
     * @summary Update current user
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerUpdate(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdate(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates user account status. Admin only.
     * @summary Update user status
     * @param {string} id User CUID
     * @param {UpdateUserStatusDto} updateUserStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerUpdateStatus(id: string, updateUserStatusDto: UpdateUserStatusDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdateStatus(id, updateUserStatusDto, options).then((request) => request(this.axios, this.basePath));
    }
}

export const UserControllerFindAllStatusEnum = {
    Active: 'active',
    Suspended: 'suspended',
    Disabled: 'disabled'
} as const;
export type UserControllerFindAllStatusEnum = typeof UserControllerFindAllStatusEnum[keyof typeof UserControllerFindAllStatusEnum];


