/* tslint:disable */
/* eslint-disable */
/**
 * Cloudberry API
 * API documentation for the Cloudberry E-commerce Api
 *
 * The version of the OpenAPI document: 1.0
 * Contact: rahilsardar234@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AddressControllerCreate201Response {
    'message': string;
    'data': AddressResponseDto;
}
export interface AddressControllerDelete200Response {
    'message': string;
    'data': object;
}
export interface AddressResponseDto {
    'id': string;
    'userId': string;
    'isPrimary': boolean;
    'houseNo'?: object;
    'street'?: object;
    'city'?: object;
    'state'?: object;
    'country'?: object;
    'pincode'?: object;
    'createdAt': string;
    'updatedAt': string;
}
export interface BadRequestErrorDto {
    'statusCode': number;
    /**
     * List of validation errors
     */
    'message': Array<string>;
    'error': string;
}
export interface CategoryControllerFindAll200Response {
    'message': string;
    'data': Array<CategoryResponseDto>;
}
export interface CategoryControllerFindOne200Response {
    'message': string;
    'data': CategoryResponseDto;
}
export interface CategoryResponseDto {
    /**
     * Category ID
     */
    'id': string;
    /**
     * Category name
     */
    'name': string;
    /**
     * Category description
     */
    'description'?: object;
    /**
     * Category image URL
     */
    'imageUrl'?: object;
    /**
     * Parent category ID
     */
    'parentId'?: object;
    /**
     * Creation timestamp
     */
    'createdAt': string;
    /**
     * Last update timestamp
     */
    'updatedAt': string;
}
export interface ConflictErrorDto {
    'statusCode': number;
    'message': string;
    'error': string;
}
export interface CreateAddressDto {
    /**
     * House number
     */
    'houseNo'?: string;
    /**
     * Street
     */
    'street'?: string;
    /**
     * City
     */
    'city'?: string;
    /**
     * State
     */
    'state'?: string;
    /**
     * Country
     */
    'country'?: string;
    /**
     * Pincode
     */
    'pincode'?: string;
    /**
     * Is primary address
     */
    'isPrimary'?: boolean;
}
export interface CreateCategoryDto {
    /**
     * Category name
     */
    'name': string;
    /**
     * Category description
     */
    'description'?: object;
    /**
     * Category image URL
     */
    'imageUrl'?: object;
    /**
     * Parent category ID for subcategories
     */
    'parentId'?: object;
}
export interface CreateProductDto {
    /**
     * Product name (catalog identity)
     */
    'name': string;
    /**
     * Product description
     */
    'description': string;
    /**
     * Category ID
     */
    'categoryId': string;
    /**
     * Brand name
     */
    'brand'?: string;
}
export interface CreateVariantDto {
    /**
     * SKU (Stock Keeping Unit) - must be unique across all variants
     */
    'sku': string;
    /**
     * Variant name (e.g., size, weight, color)
     */
    'variantName': string;
    /**
     * Price (base price before discount)
     */
    'price': number;
    /**
     * Stock quantity
     */
    'stock': number;
    /**
     * Discount percentage (0-100)
     */
    'discountPercent'?: number;
    /**
     * Seller profile ID (who sells this variant)
     */
    'sellerProfileId'?: string;
    /**
     * Image URL for this specific variant
     */
    'imageUrl'?: string;
}
export interface CustomerProfileDto {
    'id': string;
    'name'?: string;
    'cartId'?: string;
}
export interface FeedControllerGetFeed200Response {
    'message': string;
    'data': Array<GetCategoryProductFeedResponseDto>;
}
export interface ForbiddenErrorDto {
    'statusCode': number;
    'message': string;
    'error': string;
}
export interface GetCategoryProductFeedResponseDto {
    /**
     * The unique identifier of the category
     */
    'id': string;
    /**
     * The name of the category
     */
    'name': string;
    /**
     * List of products in the category
     */
    'products': Array<ProductDto>;
}
export interface HttpPaginatedResponse {
    'message': string;
    'data'?: object;
    /**
     * Pagination metadata
     */
    'meta': PaginationMetaDto;
}
export interface HttpResponse {
    'message': string;
    'data'?: object;
}
export interface InternalServerErrorDto {
    'statusCode': number;
    'message': string;
    'error': string;
}
export interface LoginDto {
    /**
     * Email or phone number
     */
    'identifier': string;
    /**
     * Authentication method (PASSWORD or OTP only)
     */
    'method': LoginDtoMethodEnum;
    /**
     * Password (required for PASSWORD method)
     */
    'password'?: string;
    /**
     * OTP code (required for OTP method)
     */
    'otp'?: string;
}

export const LoginDtoMethodEnum = {
    Password: 'PASSWORD',
    Otp: 'OTP'
} as const;

export type LoginDtoMethodEnum = typeof LoginDtoMethodEnum[keyof typeof LoginDtoMethodEnum];

export interface LoginWithGoogleDto {
    /**
     * Google ID token
     */
    'idToken': string;
}
export interface MeResponseDto {
    'userId': string;
    'email'?: string;
    'role': MeResponseDtoRoleEnum;
    'status': MeResponseDtoStatusEnum;
    'customerProfile'?: CustomerProfileDto;
    'sellerProfile'?: SellerProfileDto;
}

export const MeResponseDtoRoleEnum = {
    Admin: 'ADMIN',
    Seller: 'SELLER',
    Customer: 'CUSTOMER'
} as const;

export type MeResponseDtoRoleEnum = typeof MeResponseDtoRoleEnum[keyof typeof MeResponseDtoRoleEnum];
export const MeResponseDtoStatusEnum = {
    Active: 'active',
    Suspended: 'suspended',
    Disabled: 'disabled'
} as const;

export type MeResponseDtoStatusEnum = typeof MeResponseDtoStatusEnum[keyof typeof MeResponseDtoStatusEnum];

export interface MessageOnlyResponse {
    'message': string;
}
export interface NotFoundErrorDto {
    'statusCode': number;
    'message': string;
    'error': string;
}
export interface PaginationMetaDto {
    /**
     * Current page number
     */
    'page': number;
    /**
     * Number of items per page
     */
    'limit': number;
    /**
     * Total number of items
     */
    'total': number;
    /**
     * Whether there is a next page
     */
    'hasNextPage': boolean;
    /**
     * Whether there is a previous page
     */
    'hasPrevPage': boolean;
}
export interface ProductControllerCreate201Response {
    'message': string;
    'data': ProductResponseDto;
}
export interface ProductControllerFindAll200Response {
    'message': string;
    'data': Array<ProductResponseDto>;
    /**
     * Pagination metadata
     */
    'meta': PaginationMetaDto;
}
export interface ProductControllerGetProductWithVariants200Response {
    'message': string;
    'data': ProductWithVariantsResponseDto;
}
export interface ProductDto {
    /**
     * The unique identifier of the product
     */
    'id': string;
    /**
     * The name of the product
     */
    'name': string;
    /**
     * The price of the product
     */
    'price': number;
    /**
     * The discount percentage of the product
     */
    'discountPercentage'?: number;
}
export interface ProductResponseDto {
    /**
     * Product ID
     */
    'id': string;
    /**
     * Product name
     */
    'name': string;
    /**
     * Product description
     */
    'description': string;
    /**
     * Category ID
     */
    'categoryId': string;
    /**
     * Brand name
     */
    'brand'?: object | null;
    /**
     * Product status (catalog lifecycle)
     */
    'status': ProductResponseDtoStatusEnum;
    /**
     * Whether product is active in catalog
     */
    'isActive': boolean;
    /**
     * Whether product is in catalog (not deleted/discontinued)
     */
    'isInCatalog': boolean;
    /**
     * Product creation date
     */
    'createdAt': string;
    /**
     * Product last update date
     */
    'updatedAt': string;
}

export const ProductResponseDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Discontinued: 'discontinued'
} as const;

export type ProductResponseDtoStatusEnum = typeof ProductResponseDtoStatusEnum[keyof typeof ProductResponseDtoStatusEnum];

export interface ProductWithVariantsResponseDto {
    /**
     * Product catalog information
     */
    'product': ProductResponseDto;
    /**
     * Sellable variants of the product
     */
    'variants': Array<VariantResponseDto>;
}
export interface RegisterDto {
    /**
     * Email address
     */
    'email'?: string;
    /**
     * Phone number
     */
    'phone'?: string;
    /**
     * Password (min 6 characters)
     */
    'password': string;
}
export interface RequestOTPDto {
    /**
     * Email or phone number
     */
    'identifier': string;
}
export interface SellerProfileDto {
    'id': string;
    'storeName': string;
    'isVerified': boolean;
}
export interface UnauthorizedErrorDto {
    'statusCode': number;
    'message': string;
    'error': string;
}
export interface UpdateAddressDto {
    /**
     * House number (set to null to clear)
     */
    'houseNo'?: string;
    /**
     * Street (set to null to clear)
     */
    'street'?: string;
    /**
     * City (set to null to clear)
     */
    'city'?: string;
    /**
     * State (set to null to clear)
     */
    'state'?: string;
    /**
     * Country (set to null to clear)
     */
    'country'?: string;
    /**
     * Pincode (set to null to clear)
     */
    'pincode'?: string;
    /**
     * Is primary address
     */
    'isPrimary'?: boolean;
}
export interface UpdateCategoryDto {
    /**
     * Category name
     */
    'name'?: string;
    /**
     * Category description
     */
    'description'?: object;
    /**
     * Category image URL
     */
    'imageUrl'?: object;
    /**
     * Parent category ID for subcategories
     */
    'parentId'?: object;
}
export interface UpdateProductDto {
    /**
     * Product name
     */
    'name'?: string;
    /**
     * Product description
     */
    'description'?: string;
    /**
     * Brand name
     */
    'brand'?: string;
    /**
     * Category ID (use with caution - cannot change if discontinued)
     */
    'categoryId'?: string;
    /**
     * Product status (catalog lifecycle)
     */
    'status'?: UpdateProductDtoStatusEnum;
}

export const UpdateProductDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Discontinued: 'discontinued'
} as const;

export type UpdateProductDtoStatusEnum = typeof UpdateProductDtoStatusEnum[keyof typeof UpdateProductDtoStatusEnum];

export interface UpdateUserDto {
    /**
     * User name
     */
    'name'?: string;
    /**
     * User email
     */
    'email'?: string;
    /**
     * User phone
     */
    'phone'?: string;
    /**
     * Date of birth
     */
    'dob'?: string;
    /**
     * Gender
     */
    'gender'?: UpdateUserDtoGenderEnum;
}

export const UpdateUserDtoGenderEnum = {
    Male: 'male',
    Female: 'female',
    Other: 'other'
} as const;

export type UpdateUserDtoGenderEnum = typeof UpdateUserDtoGenderEnum[keyof typeof UpdateUserDtoGenderEnum];

export interface UpdateUserStatusDto {
    /**
     * Account status
     */
    'status': UpdateUserStatusDtoStatusEnum;
}

export const UpdateUserStatusDtoStatusEnum = {
    Active: 'active',
    Suspended: 'suspended',
    Disabled: 'disabled'
} as const;

export type UpdateUserStatusDtoStatusEnum = typeof UpdateUserStatusDtoStatusEnum[keyof typeof UpdateUserStatusDtoStatusEnum];

export interface UpdateVariantDto {
    /**
     * Variant name
     */
    'variantName'?: string;
    /**
     * Price (base price before discount)
     */
    'price'?: number;
    /**
     * Discount percentage (0-100, set to 0 to remove discount)
     */
    'discountPercent'?: number;
    /**
     * Stock quantity
     */
    'stock'?: number;
    /**
     * Variant status
     */
    'status'?: UpdateVariantDtoStatusEnum;
    /**
     * Whether variant is active (available for purchase)
     */
    'isActive'?: boolean;
    /**
     * Seller profile ID (null to remove seller)
     */
    'sellerProfileId'?: object | null;
    /**
     * Image URL for this variant
     */
    'imageUrl'?: object | null;
}

export const UpdateVariantDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    OutOfStock: 'out_of_stock'
} as const;

export type UpdateVariantDtoStatusEnum = typeof UpdateVariantDtoStatusEnum[keyof typeof UpdateVariantDtoStatusEnum];

export interface UpdateVariantStockDto {
    /**
     * Stock action type
     */
    'action': UpdateVariantStockDtoActionEnum;
    /**
     * Stock quantity
     */
    'quantity': number;
}

export const UpdateVariantStockDtoActionEnum = {
    Set: 'set',
    Add: 'add',
    Reduce: 'reduce'
} as const;

export type UpdateVariantStockDtoActionEnum = typeof UpdateVariantStockDtoActionEnum[keyof typeof UpdateVariantStockDtoActionEnum];

export interface UserControllerFindAll200Response {
    'message': string;
    'data': Array<UserResponseDto>;
    /**
     * Pagination metadata
     */
    'meta': PaginationMetaDto;
}
export interface UserControllerGetMe200Response {
    'message': string;
    'data': MeResponseDto;
}
export interface UserControllerUpdate200Response {
    'message': string;
    'data': UserResponseDto;
}
export interface UserResponseDto {
    'id': string;
    'email'?: object;
    'phone'?: object;
    'role': UserResponseDtoRoleEnum;
    'status': UserResponseDtoStatusEnum;
    'createdAt': string;
    'updatedAt': string;
}

export const UserResponseDtoRoleEnum = {
    Admin: 'ADMIN',
    Seller: 'SELLER',
    Customer: 'CUSTOMER'
} as const;

export type UserResponseDtoRoleEnum = typeof UserResponseDtoRoleEnum[keyof typeof UserResponseDtoRoleEnum];
export const UserResponseDtoStatusEnum = {
    Active: 'active',
    Suspended: 'suspended',
    Disabled: 'disabled'
} as const;

export type UserResponseDtoStatusEnum = typeof UserResponseDtoStatusEnum[keyof typeof UserResponseDtoStatusEnum];

export interface VariantControllerCreateVariant201Response {
    'message': string;
    'data': VariantResponseDto;
}
export interface VariantControllerGetVariantsByProduct200Response {
    'message': string;
    'data': Array<VariantResponseDto>;
}
export interface VariantResponseDto {
    /**
     * Variant ID
     */
    'id': string;
    /**
     * Product ID
     */
    'productId': string;
    /**
     * SKU (Stock Keeping Unit)
     */
    'sku': string;
    /**
     * Variant name
     */
    'variantName': string;
    /**
     * Base price
     */
    'price': number;
    /**
     * Discount percentage
     */
    'discountPercent': number;
    /**
     * Final price after discount
     */
    'finalPrice': number;
    /**
     * Stock quantity
     */
    'stock': number;
    /**
     * Variant status
     */
    'status': VariantResponseDtoStatusEnum;
    /**
     * Whether variant is active
     */
    'isActive': boolean;
    /**
     * Whether variant is in stock
     */
    'inStock': boolean;
    /**
     * Whether variant is available for purchase
     */
    'availableForPurchase': boolean;
    /**
     * Seller profile ID
     */
    'sellerProfileId'?: object | null;
    /**
     * Additional attributes
     */
    'attributes'?: object | null;
    /**
     * Image URL
     */
    'imageUrl'?: object | null;
    /**
     * Creation date
     */
    'createdAt': string;
    /**
     * Last update date
     */
    'updatedAt': string;
}

export const VariantResponseDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    OutOfStock: 'out_of_stock'
} as const;

export type VariantResponseDtoStatusEnum = typeof VariantResponseDtoStatusEnum[keyof typeof VariantResponseDtoStatusEnum];

export interface VerifyOTPDto {
    /**
     * Email or phone number
     */
    'identifier': string;
    /**
     * OTP code (4 digits)
     */
    'otp': string;
}

/**
 * AddressesApi - axios parameter creator
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new address for the authenticated user
         * @summary Create address
         * @param {CreateAddressDto} createAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerCreate: async (createAddressDto: CreateAddressDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAddressDto' is not null or undefined
            assertParamExists('addressControllerCreate', 'createAddressDto', createAddressDto)
            const localVarPath = `/api/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAddressDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing address for the authenticated user
         * @summary Delete address
         * @param {string} id Address UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addressControllerDelete', 'id', id)
            const localVarPath = `/api/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing address for the authenticated user
         * @summary Update address
         * @param {string} id Address UUID
         * @param {UpdateAddressDto} updateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerUpdate: async (id: string, updateAddressDto: UpdateAddressDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addressControllerUpdate', 'id', id)
            // verify required parameter 'updateAddressDto' is not null or undefined
            assertParamExists('addressControllerUpdate', 'updateAddressDto', updateAddressDto)
            const localVarPath = `/api/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAddressDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 */
export const AddressesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new address for the authenticated user
         * @summary Create address
         * @param {CreateAddressDto} createAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressControllerCreate(createAddressDto: CreateAddressDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressControllerCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressControllerCreate(createAddressDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.addressControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an existing address for the authenticated user
         * @summary Delete address
         * @param {string} id Address UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressControllerDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressControllerDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressControllerDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.addressControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing address for the authenticated user
         * @summary Update address
         * @param {string} id Address UUID
         * @param {UpdateAddressDto} updateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressControllerUpdate(id: string, updateAddressDto: UpdateAddressDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressControllerCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressControllerUpdate(id, updateAddressDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.addressControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressesApi - factory interface
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressesApiFp(configuration)
    return {
        /**
         * Creates a new address for the authenticated user
         * @summary Create address
         * @param {CreateAddressDto} createAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerCreate(createAddressDto: CreateAddressDto, options?: RawAxiosRequestConfig): AxiosPromise<AddressControllerCreate201Response> {
            return localVarFp.addressControllerCreate(createAddressDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing address for the authenticated user
         * @summary Delete address
         * @param {string} id Address UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressControllerDelete200Response> {
            return localVarFp.addressControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing address for the authenticated user
         * @summary Update address
         * @param {string} id Address UUID
         * @param {UpdateAddressDto} updateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerUpdate(id: string, updateAddressDto: UpdateAddressDto, options?: RawAxiosRequestConfig): AxiosPromise<AddressControllerCreate201Response> {
            return localVarFp.addressControllerUpdate(id, updateAddressDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressesApi - object-oriented interface
 */
export class AddressesApi extends BaseAPI {
    /**
     * Creates a new address for the authenticated user
     * @summary Create address
     * @param {CreateAddressDto} createAddressDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressControllerCreate(createAddressDto: CreateAddressDto, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).addressControllerCreate(createAddressDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing address for the authenticated user
     * @summary Delete address
     * @param {string} id Address UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressControllerDelete(id: string, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).addressControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing address for the authenticated user
     * @summary Update address
     * @param {string} id Address UUID
     * @param {UpdateAddressDto} updateAddressDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addressControllerUpdate(id: string, updateAddressDto: UpdateAddressDto, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).addressControllerUpdate(id, updateAddressDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate user with password or OTP
         * @summary Login with password or OTP
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate user with Google OAuth
         * @summary Login with Google
         * @param {LoginWithGoogleDto} loginWithGoogleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithGoogle: async (loginWithGoogleDto: LoginWithGoogleDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginWithGoogleDto' is not null or undefined
            assertParamExists('authControllerLoginWithGoogle', 'loginWithGoogleDto', loginWithGoogleDto)
            const localVarPath = `/api/auth/login/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginWithGoogleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear authentication cookies
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get new access token using refresh token
         * @summary Refresh access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new customer account with email/phone and password
         * @summary Register a new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister: async (registerDto: RegisterDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerDto' is not null or undefined
            assertParamExists('authControllerRegister', 'registerDto', registerDto)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send OTP to email or phone number
         * @summary Request OTP
         * @param {RequestOTPDto} requestOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRequestOTP: async (requestOTPDto: RequestOTPDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestOTPDto' is not null or undefined
            assertParamExists('authControllerRequestOTP', 'requestOTPDto', requestOTPDto)
            const localVarPath = `/api/auth/otp/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestOTPDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify OTP code
         * @summary Verify OTP
         * @param {VerifyOTPDto} verifyOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyOTP: async (verifyOTPDto: VerifyOTPDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyOTPDto' is not null or undefined
            assertParamExists('authControllerVerifyOTP', 'verifyOTPDto', verifyOTPDto)
            const localVarPath = `/api/auth/otp/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyOTPDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate user with password or OTP
         * @summary Login with password or OTP
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate user with Google OAuth
         * @summary Login with Google
         * @param {LoginWithGoogleDto} loginWithGoogleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLoginWithGoogle(loginWithGoogleDto: LoginWithGoogleDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLoginWithGoogle(loginWithGoogleDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLoginWithGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clear authentication cookies
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get new access token using refresh token
         * @summary Refresh access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefreshToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefreshToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerRefreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new customer account with email/phone and password
         * @summary Register a new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRegister(registerDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send OTP to email or phone number
         * @summary Request OTP
         * @param {RequestOTPDto} requestOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRequestOTP(requestOTPDto: RequestOTPDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRequestOTP(requestOTPDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerRequestOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify OTP code
         * @summary Verify OTP
         * @param {VerifyOTPDto} verifyOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerVerifyOTP(verifyOTPDto: VerifyOTPDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerifyOTP(verifyOTPDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerVerifyOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Authenticate user with password or OTP
         * @summary Login with password or OTP
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.authControllerLogin(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate user with Google OAuth
         * @summary Login with Google
         * @param {LoginWithGoogleDto} loginWithGoogleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithGoogle(loginWithGoogleDto: LoginWithGoogleDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.authControllerLoginWithGoogle(loginWithGoogleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Clear authentication cookies
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout(options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.authControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Get new access token using refresh token
         * @summary Refresh access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken(options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.authControllerRefreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new customer account with email/phone and password
         * @summary Register a new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.authControllerRegister(registerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Send OTP to email or phone number
         * @summary Request OTP
         * @param {RequestOTPDto} requestOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRequestOTP(requestOTPDto: RequestOTPDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.authControllerRequestOTP(requestOTPDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify OTP code
         * @summary Verify OTP
         * @param {VerifyOTPDto} verifyOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyOTP(verifyOTPDto: VerifyOTPDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.authControllerVerifyOTP(verifyOTPDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Authenticate user with password or OTP
     * @summary Login with password or OTP
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLogin(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate user with Google OAuth
     * @summary Login with Google
     * @param {LoginWithGoogleDto} loginWithGoogleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerLoginWithGoogle(loginWithGoogleDto: LoginWithGoogleDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLoginWithGoogle(loginWithGoogleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear authentication cookies
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerLogout(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get new access token using refresh token
     * @summary Refresh access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerRefreshToken(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerRefreshToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new customer account with email/phone and password
     * @summary Register a new user
     * @param {RegisterDto} registerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerRegister(registerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send OTP to email or phone number
     * @summary Request OTP
     * @param {RequestOTPDto} requestOTPDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerRequestOTP(requestOTPDto: RequestOTPDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerRequestOTP(requestOTPDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify OTP code
     * @summary Verify OTP
     * @param {VerifyOTPDto} verifyOTPDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerVerifyOTP(verifyOTPDto: VerifyOTPDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerVerifyOTP(verifyOTPDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoriesApi - axios parameter creator
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new category with the provided details. Only admins can create categories.
         * @summary Create a new category
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerCreate: async (createCategoryDto: CreateCategoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCategoryDto' is not null or undefined
            assertParamExists('categoryControllerCreate', 'createCategoryDto', createCategoryDto)
            const localVarPath = `/api/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all categories
         * @summary Get all categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single category by its ID
         * @summary Get category by ID
         * @param {string} id Category UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoryControllerFindOne', 'id', id)
            const localVarPath = `/api/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a category. Only admins can delete categories.
         * @summary Delete category
         * @param {string} id Category UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoryControllerRemove', 'id', id)
            const localVarPath = `/api/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing category. Only admins can update categories.
         * @summary Update category
         * @param {string} id Category UUID
         * @param {UpdateCategoryDto} updateCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerUpdate: async (id: string, updateCategoryDto: UpdateCategoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoryControllerUpdate', 'id', id)
            // verify required parameter 'updateCategoryDto' is not null or undefined
            assertParamExists('categoryControllerUpdate', 'updateCategoryDto', updateCategoryDto)
            const localVarPath = `/api/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new category with the provided details. Only admins can create categories.
         * @summary Create a new category
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerCreate(createCategoryDto: CreateCategoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerCreate(createCategoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.categoryControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all categories
         * @summary Get all categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryControllerFindAll200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.categoryControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single category by its ID
         * @summary Get category by ID
         * @param {string} id Category UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.categoryControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a category. Only admins can delete categories.
         * @summary Delete category
         * @param {string} id Category UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.categoryControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing category. Only admins can update categories.
         * @summary Update category
         * @param {string} id Category UUID
         * @param {UpdateCategoryDto} updateCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerUpdate(id: string, updateCategoryDto: UpdateCategoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerUpdate(id, updateCategoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.categoryControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoriesApi - factory interface
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * Creates a new category with the provided details. Only admins can create categories.
         * @summary Create a new category
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerCreate(createCategoryDto: CreateCategoryDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.categoryControllerCreate(createCategoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all categories
         * @summary Get all categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<CategoryControllerFindAll200Response> {
            return localVarFp.categoryControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single category by its ID
         * @summary Get category by ID
         * @param {string} id Category UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CategoryControllerFindOne200Response> {
            return localVarFp.categoryControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a category. Only admins can delete categories.
         * @summary Delete category
         * @param {string} id Category UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.categoryControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing category. Only admins can update categories.
         * @summary Update category
         * @param {string} id Category UUID
         * @param {UpdateCategoryDto} updateCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerUpdate(id: string, updateCategoryDto: UpdateCategoryDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.categoryControllerUpdate(id, updateCategoryDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Creates a new category with the provided details. Only admins can create categories.
     * @summary Create a new category
     * @param {CreateCategoryDto} createCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryControllerCreate(createCategoryDto: CreateCategoryDto, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoryControllerCreate(createCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all categories
     * @summary Get all categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryControllerFindAll(options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoryControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single category by its ID
     * @summary Get category by ID
     * @param {string} id Category UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoryControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a category. Only admins can delete categories.
     * @summary Delete category
     * @param {string} id Category UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoryControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing category. Only admins can update categories.
     * @summary Update category
     * @param {string} id Category UUID
     * @param {UpdateCategoryDto} updateCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryControllerUpdate(id: string, updateCategoryDto: UpdateCategoryDto, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoryControllerUpdate(id, updateCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeedsApi - axios parameter creator
 */
export const FeedsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves categories with their products for feed display
         * @summary Get category product feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedControllerGetFeed: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/feed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedsApi - functional programming interface
 */
export const FeedsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves categories with their products for feed display
         * @summary Get category product feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedControllerGetFeed(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedControllerGetFeed200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedControllerGetFeed(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedsApi.feedControllerGetFeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeedsApi - factory interface
 */
export const FeedsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedsApiFp(configuration)
    return {
        /**
         * Retrieves categories with their products for feed display
         * @summary Get category product feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedControllerGetFeed(options?: RawAxiosRequestConfig): AxiosPromise<FeedControllerGetFeed200Response> {
            return localVarFp.feedControllerGetFeed(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedsApi - object-oriented interface
 */
export class FeedsApi extends BaseAPI {
    /**
     * Retrieves categories with their products for feed display
     * @summary Get category product feed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public feedControllerGetFeed(options?: RawAxiosRequestConfig) {
        return FeedsApiFp(this.configuration).feedControllerGetFeed(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductVariantsApi - axios parameter creator
 */
export const ProductVariantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Makes variant available for purchase (if stock > 0).
         * @summary Activate variant
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerActivateVariant: async (variantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('variantControllerActivateVariant', 'variantId', variantId)
            const localVarPath = `/api/products/variants/{variantId}/activate`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new sellable variant for an existing product. Required to make product purchasable.
         * @summary Add variant to product
         * @param {string} productId Product UUID to add variant to
         * @param {CreateVariantDto} createVariantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerCreateVariant: async (productId: string, createVariantDto: CreateVariantDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('variantControllerCreateVariant', 'productId', productId)
            // verify required parameter 'createVariantDto' is not null or undefined
            assertParamExists('variantControllerCreateVariant', 'createVariantDto', createVariantDto)
            const localVarPath = `/api/products/{productId}/variants`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVariantDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Makes variant unavailable for purchase (temporarily).
         * @summary Deactivate variant
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerDeactivateVariant: async (variantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('variantControllerDeactivateVariant', 'variantId', variantId)
            const localVarPath = `/api/products/variants/{variantId}/deactivate`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Soft deletes a variant. Admin only.
         * @summary Delete variant (soft delete)
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerDeleteVariant: async (variantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('variantControllerDeleteVariant', 'variantId', variantId)
            const localVarPath = `/api/products/variants/{variantId}`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information about a specific variant.
         * @summary Get variant by ID
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerGetVariant: async (variantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('variantControllerGetVariant', 'variantId', variantId)
            const localVarPath = `/api/products/variants/{variantId}`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all variants (sizes, types) available for a product.
         * @summary List all variants for a product
         * @param {string} productId Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerGetVariantsByProduct: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('variantControllerGetVariantsByProduct', 'productId', productId)
            const localVarPath = `/api/products/{productId}/variants`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dedicated endpoint for stock management. Supports set, add, and reduce operations.
         * @summary Update variant stock
         * @param {string} variantId Variant UUID
         * @param {UpdateVariantStockDto} updateVariantStockDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerUpdateStock: async (variantId: string, updateVariantStockDto: UpdateVariantStockDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('variantControllerUpdateStock', 'variantId', variantId)
            // verify required parameter 'updateVariantStockDto' is not null or undefined
            assertParamExists('variantControllerUpdateStock', 'updateVariantStockDto', updateVariantStockDto)
            const localVarPath = `/api/products/variants/{variantId}/stock`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVariantStockDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates commerce attributes of a variant (price, stock, discount, etc.). Use dedicated endpoints for specific operations.
         * @summary Update variant details
         * @param {string} variantId Variant UUID
         * @param {UpdateVariantDto} updateVariantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerUpdateVariant: async (variantId: string, updateVariantDto: UpdateVariantDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('variantControllerUpdateVariant', 'variantId', variantId)
            // verify required parameter 'updateVariantDto' is not null or undefined
            assertParamExists('variantControllerUpdateVariant', 'updateVariantDto', updateVariantDto)
            const localVarPath = `/api/products/variants/{variantId}`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVariantDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductVariantsApi - functional programming interface
 */
export const ProductVariantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductVariantsApiAxiosParamCreator(configuration)
    return {
        /**
         * Makes variant available for purchase (if stock > 0).
         * @summary Activate variant
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerActivateVariant(variantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerActivateVariant(variantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerActivateVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new sellable variant for an existing product. Required to make product purchasable.
         * @summary Add variant to product
         * @param {string} productId Product UUID to add variant to
         * @param {CreateVariantDto} createVariantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerCreateVariant(productId: string, createVariantDto: CreateVariantDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantControllerCreateVariant201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerCreateVariant(productId, createVariantDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerCreateVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Makes variant unavailable for purchase (temporarily).
         * @summary Deactivate variant
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerDeactivateVariant(variantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerDeactivateVariant(variantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerDeactivateVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Soft deletes a variant. Admin only.
         * @summary Delete variant (soft delete)
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerDeleteVariant(variantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerDeleteVariant(variantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerDeleteVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information about a specific variant.
         * @summary Get variant by ID
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerGetVariant(variantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantControllerCreateVariant201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerGetVariant(variantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerGetVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all variants (sizes, types) available for a product.
         * @summary List all variants for a product
         * @param {string} productId Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerGetVariantsByProduct(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantControllerGetVariantsByProduct200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerGetVariantsByProduct(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerGetVariantsByProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dedicated endpoint for stock management. Supports set, add, and reduce operations.
         * @summary Update variant stock
         * @param {string} variantId Variant UUID
         * @param {UpdateVariantStockDto} updateVariantStockDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerUpdateStock(variantId: string, updateVariantStockDto: UpdateVariantStockDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerUpdateStock(variantId, updateVariantStockDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerUpdateStock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates commerce attributes of a variant (price, stock, discount, etc.). Use dedicated endpoints for specific operations.
         * @summary Update variant details
         * @param {string} variantId Variant UUID
         * @param {UpdateVariantDto} updateVariantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variantControllerUpdateVariant(variantId: string, updateVariantDto: UpdateVariantDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variantControllerUpdateVariant(variantId, updateVariantDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductVariantsApi.variantControllerUpdateVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductVariantsApi - factory interface
 */
export const ProductVariantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductVariantsApiFp(configuration)
    return {
        /**
         * Makes variant available for purchase (if stock > 0).
         * @summary Activate variant
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerActivateVariant(variantId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.variantControllerActivateVariant(variantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new sellable variant for an existing product. Required to make product purchasable.
         * @summary Add variant to product
         * @param {string} productId Product UUID to add variant to
         * @param {CreateVariantDto} createVariantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerCreateVariant(productId: string, createVariantDto: CreateVariantDto, options?: RawAxiosRequestConfig): AxiosPromise<VariantControllerCreateVariant201Response> {
            return localVarFp.variantControllerCreateVariant(productId, createVariantDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Makes variant unavailable for purchase (temporarily).
         * @summary Deactivate variant
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerDeactivateVariant(variantId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.variantControllerDeactivateVariant(variantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Soft deletes a variant. Admin only.
         * @summary Delete variant (soft delete)
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerDeleteVariant(variantId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.variantControllerDeleteVariant(variantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about a specific variant.
         * @summary Get variant by ID
         * @param {string} variantId Variant UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerGetVariant(variantId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantControllerCreateVariant201Response> {
            return localVarFp.variantControllerGetVariant(variantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all variants (sizes, types) available for a product.
         * @summary List all variants for a product
         * @param {string} productId Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerGetVariantsByProduct(productId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantControllerGetVariantsByProduct200Response> {
            return localVarFp.variantControllerGetVariantsByProduct(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Dedicated endpoint for stock management. Supports set, add, and reduce operations.
         * @summary Update variant stock
         * @param {string} variantId Variant UUID
         * @param {UpdateVariantStockDto} updateVariantStockDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerUpdateStock(variantId: string, updateVariantStockDto: UpdateVariantStockDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.variantControllerUpdateStock(variantId, updateVariantStockDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates commerce attributes of a variant (price, stock, discount, etc.). Use dedicated endpoints for specific operations.
         * @summary Update variant details
         * @param {string} variantId Variant UUID
         * @param {UpdateVariantDto} updateVariantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variantControllerUpdateVariant(variantId: string, updateVariantDto: UpdateVariantDto, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.variantControllerUpdateVariant(variantId, updateVariantDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductVariantsApi - object-oriented interface
 */
export class ProductVariantsApi extends BaseAPI {
    /**
     * Makes variant available for purchase (if stock > 0).
     * @summary Activate variant
     * @param {string} variantId Variant UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerActivateVariant(variantId: string, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerActivateVariant(variantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new sellable variant for an existing product. Required to make product purchasable.
     * @summary Add variant to product
     * @param {string} productId Product UUID to add variant to
     * @param {CreateVariantDto} createVariantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerCreateVariant(productId: string, createVariantDto: CreateVariantDto, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerCreateVariant(productId, createVariantDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Makes variant unavailable for purchase (temporarily).
     * @summary Deactivate variant
     * @param {string} variantId Variant UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerDeactivateVariant(variantId: string, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerDeactivateVariant(variantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Soft deletes a variant. Admin only.
     * @summary Delete variant (soft delete)
     * @param {string} variantId Variant UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerDeleteVariant(variantId: string, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerDeleteVariant(variantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information about a specific variant.
     * @summary Get variant by ID
     * @param {string} variantId Variant UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerGetVariant(variantId: string, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerGetVariant(variantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all variants (sizes, types) available for a product.
     * @summary List all variants for a product
     * @param {string} productId Product UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerGetVariantsByProduct(productId: string, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerGetVariantsByProduct(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dedicated endpoint for stock management. Supports set, add, and reduce operations.
     * @summary Update variant stock
     * @param {string} variantId Variant UUID
     * @param {UpdateVariantStockDto} updateVariantStockDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerUpdateStock(variantId: string, updateVariantStockDto: UpdateVariantStockDto, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerUpdateStock(variantId, updateVariantStockDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates commerce attributes of a variant (price, stock, discount, etc.). Use dedicated endpoints for specific operations.
     * @summary Update variant details
     * @param {string} variantId Variant UUID
     * @param {UpdateVariantDto} updateVariantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variantControllerUpdateVariant(variantId: string, updateVariantDto: UpdateVariantDto, options?: RawAxiosRequestConfig) {
        return ProductVariantsApiFp(this.configuration).variantControllerUpdateVariant(variantId, updateVariantDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductsApi - axios parameter creator
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Makes product visible in catalog.
         * @summary Activate product
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerActivateProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productControllerActivateProduct', 'id', id)
            const localVarPath = `/api/products/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a product catalog entry. This is NOT sellable yet - you must add variants to make it purchasable.
         * @summary Create new product (catalog entry)
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerCreate: async (createProductDto: CreateProductDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProductDto' is not null or undefined
            assertParamExists('productControllerCreate', 'createProductDto', createProductDto)
            const localVarPath = `/api/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hides product from catalog.
         * @summary Deactivate product
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerDeactivateProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productControllerDeactivateProduct', 'id', id)
            const localVarPath = `/api/products/{id}/deactivate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Soft deletes product. Admin only.
         * @summary Delete product (soft delete)
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerDeleteProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productControllerDeleteProduct', 'id', id)
            const localVarPath = `/api/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently removes product. ONE-WAY operation.
         * @summary Discontinue product (permanent)
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerDiscontinueProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productControllerDiscontinueProduct', 'id', id)
            const localVarPath = `/api/products/{id}/discontinue`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves paginated list of products with optional filtering.
         * @summary List all products (with pagination)
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term for product name or description
         * @param {string} [categoryId] Filter by category ID
         * @param {string} [status] Filter by product status
         * @param {ProductControllerFindAllSortByEnum} [sortBy] Sort by field
         * @param {ProductControllerFindAllSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindAll: async (page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: ProductControllerFindAllSortByEnum, sortOrder?: ProductControllerFindAllSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed product information.
         * @summary Get product by ID
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productControllerFindOne', 'id', id)
            const localVarPath = `/api/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns product details along with all variants. Useful for product detail pages.
         * @summary Get product with all variants
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerGetProductWithVariants: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productControllerGetProductWithVariants', 'id', id)
            const localVarPath = `/api/products/{id}/with-variants`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates catalog information only. Does NOT affect pricing or stock.
         * @summary Update product information
         * @param {string} id Product UUID
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerUpdate: async (id: string, updateProductDto: UpdateProductDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productControllerUpdate', 'id', id)
            // verify required parameter 'updateProductDto' is not null or undefined
            assertParamExists('productControllerUpdate', 'updateProductDto', updateProductDto)
            const localVarPath = `/api/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Makes product visible in catalog.
         * @summary Activate product
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerActivateProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerActivateProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.productControllerActivateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a product catalog entry. This is NOT sellable yet - you must add variants to make it purchasable.
         * @summary Create new product (catalog entry)
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerCreate(createProductDto: CreateProductDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductControllerCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerCreate(createProductDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.productControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Hides product from catalog.
         * @summary Deactivate product
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerDeactivateProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerDeactivateProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.productControllerDeactivateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Soft deletes product. Admin only.
         * @summary Delete product (soft delete)
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerDeleteProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerDeleteProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.productControllerDeleteProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently removes product. ONE-WAY operation.
         * @summary Discontinue product (permanent)
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerDiscontinueProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOnlyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerDiscontinueProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.productControllerDiscontinueProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves paginated list of products with optional filtering.
         * @summary List all products (with pagination)
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term for product name or description
         * @param {string} [categoryId] Filter by category ID
         * @param {string} [status] Filter by product status
         * @param {ProductControllerFindAllSortByEnum} [sortBy] Sort by field
         * @param {ProductControllerFindAllSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerFindAll(page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: ProductControllerFindAllSortByEnum, sortOrder?: ProductControllerFindAllSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductControllerFindAll200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerFindAll(page, limit, search, categoryId, status, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.productControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed product information.
         * @summary Get product by ID
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductControllerCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.productControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns product details along with all variants. Useful for product detail pages.
         * @summary Get product with all variants
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerGetProductWithVariants(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductControllerGetProductWithVariants200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerGetProductWithVariants(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.productControllerGetProductWithVariants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates catalog information only. Does NOT affect pricing or stock.
         * @summary Update product information
         * @param {string} id Product UUID
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductControllerCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerUpdate(id, updateProductDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.productControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductsApi - factory interface
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * Makes product visible in catalog.
         * @summary Activate product
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerActivateProduct(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.productControllerActivateProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a product catalog entry. This is NOT sellable yet - you must add variants to make it purchasable.
         * @summary Create new product (catalog entry)
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerCreate(createProductDto: CreateProductDto, options?: RawAxiosRequestConfig): AxiosPromise<ProductControllerCreate201Response> {
            return localVarFp.productControllerCreate(createProductDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Hides product from catalog.
         * @summary Deactivate product
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerDeactivateProduct(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.productControllerDeactivateProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Soft deletes product. Admin only.
         * @summary Delete product (soft delete)
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerDeleteProduct(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.productControllerDeleteProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently removes product. ONE-WAY operation.
         * @summary Discontinue product (permanent)
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerDiscontinueProduct(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageOnlyResponse> {
            return localVarFp.productControllerDiscontinueProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves paginated list of products with optional filtering.
         * @summary List all products (with pagination)
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term for product name or description
         * @param {string} [categoryId] Filter by category ID
         * @param {string} [status] Filter by product status
         * @param {ProductControllerFindAllSortByEnum} [sortBy] Sort by field
         * @param {ProductControllerFindAllSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindAll(page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: ProductControllerFindAllSortByEnum, sortOrder?: ProductControllerFindAllSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<ProductControllerFindAll200Response> {
            return localVarFp.productControllerFindAll(page, limit, search, categoryId, status, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed product information.
         * @summary Get product by ID
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductControllerCreate201Response> {
            return localVarFp.productControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns product details along with all variants. Useful for product detail pages.
         * @summary Get product with all variants
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerGetProductWithVariants(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductControllerGetProductWithVariants200Response> {
            return localVarFp.productControllerGetProductWithVariants(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates catalog information only. Does NOT affect pricing or stock.
         * @summary Update product information
         * @param {string} id Product UUID
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig): AxiosPromise<ProductControllerCreate201Response> {
            return localVarFp.productControllerUpdate(id, updateProductDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 */
export class ProductsApi extends BaseAPI {
    /**
     * Makes product visible in catalog.
     * @summary Activate product
     * @param {string} id Product UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productControllerActivateProduct(id: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productControllerActivateProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a product catalog entry. This is NOT sellable yet - you must add variants to make it purchasable.
     * @summary Create new product (catalog entry)
     * @param {CreateProductDto} createProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productControllerCreate(createProductDto: CreateProductDto, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productControllerCreate(createProductDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Hides product from catalog.
     * @summary Deactivate product
     * @param {string} id Product UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productControllerDeactivateProduct(id: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productControllerDeactivateProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Soft deletes product. Admin only.
     * @summary Delete product (soft delete)
     * @param {string} id Product UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productControllerDeleteProduct(id: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productControllerDeleteProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently removes product. ONE-WAY operation.
     * @summary Discontinue product (permanent)
     * @param {string} id Product UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productControllerDiscontinueProduct(id: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productControllerDiscontinueProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves paginated list of products with optional filtering.
     * @summary List all products (with pagination)
     * @param {number} [page] Page number
     * @param {number} [limit] Number of items per page
     * @param {string} [search] Search term for product name or description
     * @param {string} [categoryId] Filter by category ID
     * @param {string} [status] Filter by product status
     * @param {ProductControllerFindAllSortByEnum} [sortBy] Sort by field
     * @param {ProductControllerFindAllSortOrderEnum} [sortOrder] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productControllerFindAll(page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: ProductControllerFindAllSortByEnum, sortOrder?: ProductControllerFindAllSortOrderEnum, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productControllerFindAll(page, limit, search, categoryId, status, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed product information.
     * @summary Get product by ID
     * @param {string} id Product UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns product details along with all variants. Useful for product detail pages.
     * @summary Get product with all variants
     * @param {string} id Product UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productControllerGetProductWithVariants(id: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productControllerGetProductWithVariants(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates catalog information only. Does NOT affect pricing or stock.
     * @summary Update product information
     * @param {string} id Product UUID
     * @param {UpdateProductDto} updateProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productControllerUpdate(id, updateProductDto, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ProductControllerFindAllSortByEnum = {
    Name: 'name',
    Price: 'price',
    CreatedAt: 'createdAt'
} as const;
export type ProductControllerFindAllSortByEnum = typeof ProductControllerFindAllSortByEnum[keyof typeof ProductControllerFindAllSortByEnum];
export const ProductControllerFindAllSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ProductControllerFindAllSortOrderEnum = typeof ProductControllerFindAllSortOrderEnum[keyof typeof ProductControllerFindAllSortOrderEnum];


/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves all users with pagination. Admin only.
         * @summary Get all users
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {string} [search] Search term
         * @param {UserControllerFindAllStatusEnum} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll: async (page?: number, limit?: number, search?: string, status?: UserControllerFindAllStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single user by ID. Admin only.
         * @summary Get user by ID
         * @param {string} id User UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerFindOne', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the authenticated user profile
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the authenticated user profile
         * @summary Update current user
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate: async (updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('userControllerUpdate', 'updateUserDto', updateUserDto)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates user account status. Admin only.
         * @summary Update user status
         * @param {string} id User UUID
         * @param {UpdateUserStatusDto} updateUserStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateStatus: async (id: string, updateUserStatusDto: UpdateUserStatusDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerUpdateStatus', 'id', id)
            // verify required parameter 'updateUserStatusDto' is not null or undefined
            assertParamExists('userControllerUpdateStatus', 'updateUserStatusDto', updateUserStatusDto)
            const localVarPath = `/api/users/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves all users with pagination. Admin only.
         * @summary Get all users
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {string} [search] Search term
         * @param {UserControllerFindAllStatusEnum} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindAll(page?: number, limit?: number, search?: string, status?: UserControllerFindAllStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerFindAll200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindAll(page, limit, search, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single user by ID. Admin only.
         * @summary Get user by ID
         * @param {string} id User UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerUpdate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the authenticated user profile
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetMe200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the authenticated user profile
         * @summary Update current user
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdate(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerUpdate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdate(updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates user account status. Admin only.
         * @summary Update user status
         * @param {string} id User UUID
         * @param {UpdateUserStatusDto} updateUserStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdateStatus(id: string, updateUserStatusDto: UpdateUserStatusDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerUpdate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdateStatus(id, updateUserStatusDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdateStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Retrieves all users with pagination. Admin only.
         * @summary Get all users
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {string} [search] Search term
         * @param {UserControllerFindAllStatusEnum} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll(page?: number, limit?: number, search?: string, status?: UserControllerFindAllStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<UserControllerFindAll200Response> {
            return localVarFp.userControllerFindAll(page, limit, search, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single user by ID. Admin only.
         * @summary Get user by ID
         * @param {string} id User UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<UserControllerUpdate200Response> {
            return localVarFp.userControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the authenticated user profile
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMe(options?: RawAxiosRequestConfig): AxiosPromise<UserControllerGetMe200Response> {
            return localVarFp.userControllerGetMe(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the authenticated user profile
         * @summary Update current user
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserControllerUpdate200Response> {
            return localVarFp.userControllerUpdate(updateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates user account status. Admin only.
         * @summary Update user status
         * @param {string} id User UUID
         * @param {UpdateUserStatusDto} updateUserStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateStatus(id: string, updateUserStatusDto: UpdateUserStatusDto, options?: RawAxiosRequestConfig): AxiosPromise<UserControllerUpdate200Response> {
            return localVarFp.userControllerUpdateStatus(id, updateUserStatusDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * Retrieves all users with pagination. Admin only.
     * @summary Get all users
     * @param {number} [page] Page number
     * @param {number} [limit] Items per page
     * @param {string} [search] Search term
     * @param {UserControllerFindAllStatusEnum} [status] Filter by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerFindAll(page?: number, limit?: number, search?: string, status?: UserControllerFindAllStatusEnum, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindAll(page, limit, search, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single user by ID. Admin only.
     * @summary Get user by ID
     * @param {string} id User UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the authenticated user profile
     * @summary Get current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerGetMe(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the authenticated user profile
     * @summary Update current user
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerUpdate(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdate(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates user account status. Admin only.
     * @summary Update user status
     * @param {string} id User UUID
     * @param {UpdateUserStatusDto} updateUserStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerUpdateStatus(id: string, updateUserStatusDto: UpdateUserStatusDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdateStatus(id, updateUserStatusDto, options).then((request) => request(this.axios, this.basePath));
    }
}

export const UserControllerFindAllStatusEnum = {
    Active: 'active',
    Suspended: 'suspended',
    Disabled: 'disabled'
} as const;
export type UserControllerFindAllStatusEnum = typeof UserControllerFindAllStatusEnum[keyof typeof UserControllerFindAllStatusEnum];


