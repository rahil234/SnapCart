/* tslint:disable */
/* eslint-disable */
/**
 * Cloudberry API
 * API documentation for the Cloudberry E-commerce Api
 *
 * The version of the OpenAPI document: 1.0
 * Contact: rahilsardar234@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AddressResponseDto {
    'id': string;
    'userId': string;
    'isPrimary': boolean;
    'houseNo'?: object;
    'street'?: object;
    'city'?: object;
    'state'?: object;
    'country'?: object;
    'pincode'?: object;
    'createdAt': string;
    'updatedAt': string;
}
export interface CategoryResponseDto {
    /**
     * Category ID
     */
    'id': string;
    /**
     * Category name
     */
    'name': string;
    /**
     * Category description
     */
    'description'?: object;
    /**
     * Category image URL
     */
    'imageUrl'?: object;
    /**
     * Parent category ID
     */
    'parentId'?: object;
    /**
     * Creation timestamp
     */
    'createdAt': string;
    /**
     * Last update timestamp
     */
    'updatedAt': string;
}
export interface CreateAddressDto {
    /**
     * House number
     */
    'houseNo'?: string;
    /**
     * Street
     */
    'street'?: string;
    /**
     * City
     */
    'city'?: string;
    /**
     * State
     */
    'state'?: string;
    /**
     * Country
     */
    'country'?: string;
    /**
     * Pincode
     */
    'pincode'?: string;
    /**
     * Is primary address
     */
    'isPrimary'?: boolean;
}
export interface CreateCategoryDto {
    /**
     * Category name
     */
    'name': string;
    /**
     * Category description
     */
    'description'?: object;
    /**
     * Category image URL
     */
    'imageUrl'?: object;
    /**
     * Parent category ID for subcategories
     */
    'parentId'?: object;
}
export interface CreateProductDto {
    /**
     * Product name
     */
    'name': string;
    /**
     * Product description
     */
    'description': string;
    /**
     * Category ID
     */
    'categoryId': string;
    /**
     * Product price in cents
     */
    'price': number;
    /**
     * Discount percentage (0-100)
     */
    'discountPercent'?: number;
    /**
     * Whether try-on feature is enabled
     */
    'tryOn'?: boolean;
}
export interface FeedControllerGetFeed200Response {
    'message': string;
    'data'?: Array<GetCategoryProductFeedResponseDto>;
}
export interface GetCategoryProductFeedResponseDto {
    /**
     * The unique identifier of the category
     */
    'id': string;
    /**
     * The name of the category
     */
    'name': string;
    /**
     * List of products in the category
     */
    'products': Array<ProductDto>;
}
export interface HttpResponse {
    'message': string;
    'data'?: object;
}
export interface LoginDto {
    /**
     * Email or phone number
     */
    'identifier': string;
    /**
     * Authentication method
     */
    'method': LoginDtoMethodEnum;
    /**
     * Password (required for PASSWORD method)
     */
    'password'?: string;
    /**
     * OTP code (required for OTP method)
     */
    'otp'?: string;
}

export const LoginDtoMethodEnum = {
    Password: 'PASSWORD',
    Otp: 'OTP',
    Google: 'GOOGLE'
} as const;

export type LoginDtoMethodEnum = typeof LoginDtoMethodEnum[keyof typeof LoginDtoMethodEnum];

export interface LoginWithGoogleDto {
    /**
     * Google ID token
     */
    'idToken': string;
}
export interface PaginatedProductsResponseDto {
    /**
     * Array of products
     */
    'data': Array<ProductResponseDto>;
    /**
     * Total number of products
     */
    'total': number;
    /**
     * Current page number
     */
    'page': number;
    /**
     * Number of items per page
     */
    'limit': number;
    /**
     * Total number of pages
     */
    'totalPages': number;
    /**
     * Whether there is a next page
     */
    'hasNext': boolean;
    /**
     * Whether there is a previous page
     */
    'hasPrev': boolean;
}
export interface ProductDto {
    /**
     * The unique identifier of the product
     */
    'id': string;
    /**
     * The name of the product
     */
    'name': string;
    /**
     * The price of the product
     */
    'price': number;
    /**
     * The discount percentage of the product
     */
    'discountPercentage'?: number;
}
export interface ProductResponseDto {
    /**
     * Product ID
     */
    'id': string;
    /**
     * Product name
     */
    'name': string;
    /**
     * Product description
     */
    'description': string;
    /**
     * Category ID
     */
    'categoryId': string;
    /**
     * Product price in cents
     */
    'price': number;
    /**
     * Discount percentage
     */
    'discountPercent'?: object | null;
    /**
     * Final price after discount in cents
     */
    'finalPrice': number;
    /**
     * Whether try-on feature is enabled
     */
    'tryOn': boolean;
    /**
     * Product status
     */
    'status': ProductResponseDtoStatusEnum;
    /**
     * Whether product is active
     */
    'isActive': boolean;
    /**
     * Whether product has discount applied
     */
    'hasDiscount': boolean;
    /**
     * Product creation date
     */
    'createdAt': string;
    /**
     * Product last update date
     */
    'updatedAt': string;
}

export const ProductResponseDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    OutOfStock: 'out_of_stock',
    Discontinued: 'discontinued'
} as const;

export type ProductResponseDtoStatusEnum = typeof ProductResponseDtoStatusEnum[keyof typeof ProductResponseDtoStatusEnum];

export interface RegisterDto {
    /**
     * Email address
     */
    'email'?: string;
    /**
     * Phone number
     */
    'phone'?: string;
    /**
     * Password (min 6 characters)
     */
    'password': string;
}
export interface RequestOTPDto {
    /**
     * Email or phone number
     */
    'identifier': string;
}
export interface UpdateAddressDto {
    /**
     * House number (set to null to clear)
     */
    'houseNo'?: string;
    /**
     * Street (set to null to clear)
     */
    'street'?: string;
    /**
     * City (set to null to clear)
     */
    'city'?: string;
    /**
     * State (set to null to clear)
     */
    'state'?: string;
    /**
     * Country (set to null to clear)
     */
    'country'?: string;
    /**
     * Pincode (set to null to clear)
     */
    'pincode'?: string;
    /**
     * Is primary address
     */
    'isPrimary'?: boolean;
}
export interface UpdateCategoryDto {
    /**
     * Category name
     */
    'name'?: string;
    /**
     * Category description
     */
    'description'?: object;
    /**
     * Category image URL
     */
    'imageUrl'?: object;
    /**
     * Parent category ID for subcategories
     */
    'parentId'?: object;
}
export interface UpdateProductDto {
    /**
     * Product name
     */
    'name'?: string;
    /**
     * Product description
     */
    'description'?: string;
    /**
     * Product price in cents
     */
    'price'?: number;
    /**
     * Discount percentage (0-100)
     */
    'discountPercent'?: number;
    /**
     * Whether try-on feature is enabled
     */
    'tryOn'?: boolean;
    /**
     * Product status
     */
    'status'?: UpdateProductDtoStatusEnum;
}

export const UpdateProductDtoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    OutOfStock: 'out_of_stock',
    Discontinued: 'discontinued'
} as const;

export type UpdateProductDtoStatusEnum = typeof UpdateProductDtoStatusEnum[keyof typeof UpdateProductDtoStatusEnum];

export interface UpdateUserDto {
    /**
     * User name
     */
    'name'?: string;
    /**
     * User email
     */
    'email'?: string;
    /**
     * User phone
     */
    'phone'?: string;
    /**
     * Date of birth
     */
    'dob'?: string;
    /**
     * Gender
     */
    'gender'?: UpdateUserDtoGenderEnum;
}

export const UpdateUserDtoGenderEnum = {
    Male: 'male',
    Female: 'female',
    Other: 'other'
} as const;

export type UpdateUserDtoGenderEnum = typeof UpdateUserDtoGenderEnum[keyof typeof UpdateUserDtoGenderEnum];

export interface UpdateUserStatusDto {
    /**
     * Account status
     */
    'status': UpdateUserStatusDtoStatusEnum;
}

export const UpdateUserStatusDtoStatusEnum = {
    Active: 'active',
    Suspended: 'suspended',
    Disabled: 'disabled'
} as const;

export type UpdateUserStatusDtoStatusEnum = typeof UpdateUserStatusDtoStatusEnum[keyof typeof UpdateUserStatusDtoStatusEnum];

export interface UserControllerGetMe200Response {
    'message': string;
    'data'?: UserResponseDto;
}
export interface UserResponseDto {
    'id': string;
    'email'?: object;
    'phone'?: object;
    'role': UserResponseDtoRoleEnum;
    'status': UserResponseDtoStatusEnum;
    'createdAt': string;
    'updatedAt': string;
}

export const UserResponseDtoRoleEnum = {
    Admin: 'ADMIN',
    Seller: 'SELLER',
    Customer: 'CUSTOMER'
} as const;

export type UserResponseDtoRoleEnum = typeof UserResponseDtoRoleEnum[keyof typeof UserResponseDtoRoleEnum];
export const UserResponseDtoStatusEnum = {
    Active: 'active',
    Suspended: 'suspended',
    Disabled: 'disabled'
} as const;

export type UserResponseDtoStatusEnum = typeof UserResponseDtoStatusEnum[keyof typeof UserResponseDtoStatusEnum];

export interface VerifyOTPDto {
    /**
     * Email or phone number
     */
    'identifier': string;
    /**
     * OTP code (4 digits)
     */
    'otp': string;
}

/**
 * AuthenticationApi - axios parameter creator
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate user with password or OTP
         * @summary Login with password or OTP
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate user with Google OAuth
         * @summary Login with Google
         * @param {LoginWithGoogleDto} loginWithGoogleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithGoogle: async (loginWithGoogleDto: LoginWithGoogleDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginWithGoogleDto' is not null or undefined
            assertParamExists('authControllerLoginWithGoogle', 'loginWithGoogleDto', loginWithGoogleDto)
            const localVarPath = `/api/auth/login/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginWithGoogleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear authentication cookies
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get new access token using refresh token
         * @summary Refresh access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new customer account with email/phone and password
         * @summary Register a new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister: async (registerDto: RegisterDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerDto' is not null or undefined
            assertParamExists('authControllerRegister', 'registerDto', registerDto)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send OTP to email or phone number
         * @summary Request OTP
         * @param {RequestOTPDto} requestOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRequestOTP: async (requestOTPDto: RequestOTPDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestOTPDto' is not null or undefined
            assertParamExists('authControllerRequestOTP', 'requestOTPDto', requestOTPDto)
            const localVarPath = `/api/auth/otp/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestOTPDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify OTP code
         * @summary Verify OTP
         * @param {VerifyOTPDto} verifyOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyOTP: async (verifyOTPDto: VerifyOTPDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyOTPDto' is not null or undefined
            assertParamExists('authControllerVerifyOTP', 'verifyOTPDto', verifyOTPDto)
            const localVarPath = `/api/auth/otp/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyOTPDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate user with password or OTP
         * @summary Login with password or OTP
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate user with Google OAuth
         * @summary Login with Google
         * @param {LoginWithGoogleDto} loginWithGoogleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLoginWithGoogle(loginWithGoogleDto: LoginWithGoogleDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLoginWithGoogle(loginWithGoogleDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLoginWithGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clear authentication cookies
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get new access token using refresh token
         * @summary Refresh access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefreshToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefreshToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerRefreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new customer account with email/phone and password
         * @summary Register a new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRegister(registerDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send OTP to email or phone number
         * @summary Request OTP
         * @param {RequestOTPDto} requestOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRequestOTP(requestOTPDto: RequestOTPDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRequestOTP(requestOTPDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerRequestOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify OTP code
         * @summary Verify OTP
         * @param {VerifyOTPDto} verifyOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerVerifyOTP(verifyOTPDto: VerifyOTPDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerifyOTP(verifyOTPDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerVerifyOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Authenticate user with password or OTP
         * @summary Login with password or OTP
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerLogin(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate user with Google OAuth
         * @summary Login with Google
         * @param {LoginWithGoogleDto} loginWithGoogleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithGoogle(loginWithGoogleDto: LoginWithGoogleDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerLoginWithGoogle(loginWithGoogleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Clear authentication cookies
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Get new access token using refresh token
         * @summary Refresh access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerRefreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new customer account with email/phone and password
         * @summary Register a new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerRegister(registerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Send OTP to email or phone number
         * @summary Request OTP
         * @param {RequestOTPDto} requestOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRequestOTP(requestOTPDto: RequestOTPDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerRequestOTP(requestOTPDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify OTP code
         * @summary Verify OTP
         * @param {VerifyOTPDto} verifyOTPDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyOTP(verifyOTPDto: VerifyOTPDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerVerifyOTP(verifyOTPDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Authenticate user with password or OTP
     * @summary Login with password or OTP
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLogin(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate user with Google OAuth
     * @summary Login with Google
     * @param {LoginWithGoogleDto} loginWithGoogleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerLoginWithGoogle(loginWithGoogleDto: LoginWithGoogleDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLoginWithGoogle(loginWithGoogleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear authentication cookies
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerLogout(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get new access token using refresh token
     * @summary Refresh access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerRefreshToken(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerRefreshToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new customer account with email/phone and password
     * @summary Register a new user
     * @param {RegisterDto} registerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerRegister(registerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send OTP to email or phone number
     * @summary Request OTP
     * @param {RequestOTPDto} requestOTPDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerRequestOTP(requestOTPDto: RequestOTPDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerRequestOTP(requestOTPDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify OTP code
     * @summary Verify OTP
     * @param {VerifyOTPDto} verifyOTPDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerVerifyOTP(verifyOTPDto: VerifyOTPDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerVerifyOTP(verifyOTPDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoriesApi - axios parameter creator
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new category with the provided details. Only admins can create categories.
         * @summary Create a new category
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerCreate: async (createCategoryDto: CreateCategoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCategoryDto' is not null or undefined
            assertParamExists('categoryControllerCreate', 'createCategoryDto', createCategoryDto)
            const localVarPath = `/api/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all categories
         * @summary Get all categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single category by its ID
         * @summary Get category by ID
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoryControllerFindOne', 'id', id)
            const localVarPath = `/api/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a category. Only admins can delete categories.
         * @summary Delete category
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoryControllerRemove', 'id', id)
            const localVarPath = `/api/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing category. Only admins can update categories.
         * @summary Update category
         * @param {string} id Category ID
         * @param {UpdateCategoryDto} updateCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerUpdate: async (id: string, updateCategoryDto: UpdateCategoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoryControllerUpdate', 'id', id)
            // verify required parameter 'updateCategoryDto' is not null or undefined
            assertParamExists('categoryControllerUpdate', 'updateCategoryDto', updateCategoryDto)
            const localVarPath = `/api/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new category with the provided details. Only admins can create categories.
         * @summary Create a new category
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerCreate(createCategoryDto: CreateCategoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerCreate(createCategoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.categoryControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all categories
         * @summary Get all categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategoryResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.categoryControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single category by its ID
         * @summary Get category by ID
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.categoryControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a category. Only admins can delete categories.
         * @summary Delete category
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.categoryControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing category. Only admins can update categories.
         * @summary Update category
         * @param {string} id Category ID
         * @param {UpdateCategoryDto} updateCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerUpdate(id: string, updateCategoryDto: UpdateCategoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerUpdate(id, updateCategoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.categoryControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoriesApi - factory interface
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * Creates a new category with the provided details. Only admins can create categories.
         * @summary Create a new category
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerCreate(createCategoryDto: CreateCategoryDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.categoryControllerCreate(createCategoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all categories
         * @summary Get all categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<CategoryResponseDto>> {
            return localVarFp.categoryControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single category by its ID
         * @summary Get category by ID
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CategoryResponseDto> {
            return localVarFp.categoryControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a category. Only admins can delete categories.
         * @summary Delete category
         * @param {string} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.categoryControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing category. Only admins can update categories.
         * @summary Update category
         * @param {string} id Category ID
         * @param {UpdateCategoryDto} updateCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerUpdate(id: string, updateCategoryDto: UpdateCategoryDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.categoryControllerUpdate(id, updateCategoryDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Creates a new category with the provided details. Only admins can create categories.
     * @summary Create a new category
     * @param {CreateCategoryDto} createCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryControllerCreate(createCategoryDto: CreateCategoryDto, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoryControllerCreate(createCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all categories
     * @summary Get all categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryControllerFindAll(options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoryControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single category by its ID
     * @summary Get category by ID
     * @param {string} id Category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoryControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a category. Only admins can delete categories.
     * @summary Delete category
     * @param {string} id Category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoryControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing category. Only admins can update categories.
     * @summary Update category
     * @param {string} id Category ID
     * @param {UpdateCategoryDto} updateCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryControllerUpdate(id: string, updateCategoryDto: UpdateCategoryDto, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoryControllerUpdate(id, updateCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeedsApi - axios parameter creator
 */
export const FeedsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedControllerGetFeed: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/feed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedsApi - functional programming interface
 */
export const FeedsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedControllerGetFeed(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedControllerGetFeed200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedControllerGetFeed(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedsApi.feedControllerGetFeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeedsApi - factory interface
 */
export const FeedsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedControllerGetFeed(options?: RawAxiosRequestConfig): AxiosPromise<FeedControllerGetFeed200Response> {
            return localVarFp.feedControllerGetFeed(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedsApi - object-oriented interface
 */
export class FeedsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public feedControllerGetFeed(options?: RawAxiosRequestConfig) {
        return FeedsApiFp(this.configuration).feedControllerGetFeed(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductsApi - axios parameter creator
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new product with the provided details. Only admins can create products.
         * @summary Create a new product
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerCreate: async (createProductDto: CreateProductDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProductDto' is not null or undefined
            assertParamExists('productControllerCreate', 'createProductDto', createProductDto)
            const localVarPath = `/api/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves paginated list of all products with filtering and search. Admin access required.
         * @summary Get all products (Admin)
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term for product name or description
         * @param {string} [categoryId] Filter by category ID
         * @param {string} [status] Filter by product status
         * @param {ProductControllerFindAllSortByEnum} [sortBy] Sort by field
         * @param {ProductControllerFindAllSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindAll: async (page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: ProductControllerFindAllSortByEnum, sortOrder?: ProductControllerFindAllSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single product by its ID. Public endpoint.
         * @summary Get product by ID
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productControllerFindOne', 'id', id)
            const localVarPath = `/api/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing product. Only admins can update products.
         * @summary Update product
         * @param {string} id Product UUID
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerUpdate: async (id: string, updateProductDto: UpdateProductDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productControllerUpdate', 'id', id)
            // verify required parameter 'updateProductDto' is not null or undefined
            assertParamExists('productControllerUpdate', 'updateProductDto', updateProductDto)
            const localVarPath = `/api/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new product with the provided details. Only admins can create products.
         * @summary Create a new product
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerCreate(createProductDto: CreateProductDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerCreate(createProductDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.productControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves paginated list of all products with filtering and search. Admin access required.
         * @summary Get all products (Admin)
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term for product name or description
         * @param {string} [categoryId] Filter by category ID
         * @param {string} [status] Filter by product status
         * @param {ProductControllerFindAllSortByEnum} [sortBy] Sort by field
         * @param {ProductControllerFindAllSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerFindAll(page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: ProductControllerFindAllSortByEnum, sortOrder?: ProductControllerFindAllSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerFindAll(page, limit, search, categoryId, status, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.productControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single product by its ID. Public endpoint.
         * @summary Get product by ID
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.productControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing product. Only admins can update products.
         * @summary Update product
         * @param {string} id Product UUID
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerUpdate(id, updateProductDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.productControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductsApi - factory interface
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * Creates a new product with the provided details. Only admins can create products.
         * @summary Create a new product
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerCreate(createProductDto: CreateProductDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.productControllerCreate(createProductDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves paginated list of all products with filtering and search. Admin access required.
         * @summary Get all products (Admin)
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term for product name or description
         * @param {string} [categoryId] Filter by category ID
         * @param {string} [status] Filter by product status
         * @param {ProductControllerFindAllSortByEnum} [sortBy] Sort by field
         * @param {ProductControllerFindAllSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindAll(page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: ProductControllerFindAllSortByEnum, sortOrder?: ProductControllerFindAllSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProductsResponseDto> {
            return localVarFp.productControllerFindAll(page, limit, search, categoryId, status, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single product by its ID. Public endpoint.
         * @summary Get product by ID
         * @param {string} id Product UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductResponseDto> {
            return localVarFp.productControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing product. Only admins can update products.
         * @summary Update product
         * @param {string} id Product UUID
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.productControllerUpdate(id, updateProductDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 */
export class ProductsApi extends BaseAPI {
    /**
     * Creates a new product with the provided details. Only admins can create products.
     * @summary Create a new product
     * @param {CreateProductDto} createProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productControllerCreate(createProductDto: CreateProductDto, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productControllerCreate(createProductDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves paginated list of all products with filtering and search. Admin access required.
     * @summary Get all products (Admin)
     * @param {number} [page] Page number
     * @param {number} [limit] Number of items per page
     * @param {string} [search] Search term for product name or description
     * @param {string} [categoryId] Filter by category ID
     * @param {string} [status] Filter by product status
     * @param {ProductControllerFindAllSortByEnum} [sortBy] Sort by field
     * @param {ProductControllerFindAllSortOrderEnum} [sortOrder] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productControllerFindAll(page?: number, limit?: number, search?: string, categoryId?: string, status?: string, sortBy?: ProductControllerFindAllSortByEnum, sortOrder?: ProductControllerFindAllSortOrderEnum, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productControllerFindAll(page, limit, search, categoryId, status, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single product by its ID. Public endpoint.
     * @summary Get product by ID
     * @param {string} id Product UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing product. Only admins can update products.
     * @summary Update product
     * @param {string} id Product UUID
     * @param {UpdateProductDto} updateProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productControllerUpdate(id, updateProductDto, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ProductControllerFindAllSortByEnum = {
    Name: 'name',
    Price: 'price',
    CreatedAt: 'createdAt'
} as const;
export type ProductControllerFindAllSortByEnum = typeof ProductControllerFindAllSortByEnum[keyof typeof ProductControllerFindAllSortByEnum];
export const ProductControllerFindAllSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ProductControllerFindAllSortOrderEnum = typeof ProductControllerFindAllSortOrderEnum[keyof typeof ProductControllerFindAllSortOrderEnum];


/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new address for the authenticated user
         * @summary Create address
         * @param {CreateAddressDto} createAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreateAddress: async (createAddressDto: CreateAddressDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAddressDto' is not null or undefined
            assertParamExists('userControllerCreateAddress', 'createAddressDto', createAddressDto)
            const localVarPath = `/api/users/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAddressDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all users with pagination. Admin only.
         * @summary Get all users
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {string} [search] Search term
         * @param {UserControllerFindAllStatusEnum} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll: async (page?: number, limit?: number, search?: string, status?: UserControllerFindAllStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single user by ID. Admin only.
         * @summary Get user by ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerFindOne', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the authenticated user profile
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the authenticated user profile
         * @summary Update current user
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate: async (updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('userControllerUpdate', 'updateUserDto', updateUserDto)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing address for the authenticated user
         * @summary Update address
         * @param {string} id Address ID
         * @param {UpdateAddressDto} updateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateAddress: async (id: string, updateAddressDto: UpdateAddressDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerUpdateAddress', 'id', id)
            // verify required parameter 'updateAddressDto' is not null or undefined
            assertParamExists('userControllerUpdateAddress', 'updateAddressDto', updateAddressDto)
            const localVarPath = `/api/users/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAddressDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates user account status. Admin only.
         * @summary Update user status
         * @param {string} id User ID
         * @param {UpdateUserStatusDto} updateUserStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateStatus: async (id: string, updateUserStatusDto: UpdateUserStatusDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerUpdateStatus', 'id', id)
            // verify required parameter 'updateUserStatusDto' is not null or undefined
            assertParamExists('userControllerUpdateStatus', 'updateUserStatusDto', updateUserStatusDto)
            const localVarPath = `/api/users/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new address for the authenticated user
         * @summary Create address
         * @param {CreateAddressDto} createAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerCreateAddress(createAddressDto: CreateAddressDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerCreateAddress(createAddressDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerCreateAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all users with pagination. Admin only.
         * @summary Get all users
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {string} [search] Search term
         * @param {UserControllerFindAllStatusEnum} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindAll(page?: number, limit?: number, search?: string, status?: UserControllerFindAllStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindAll(page, limit, search, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single user by ID. Admin only.
         * @summary Get user by ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the authenticated user profile
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetMe200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the authenticated user profile
         * @summary Update current user
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdate(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdate(updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing address for the authenticated user
         * @summary Update address
         * @param {string} id Address ID
         * @param {UpdateAddressDto} updateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdateAddress(id: string, updateAddressDto: UpdateAddressDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdateAddress(id, updateAddressDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdateAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates user account status. Admin only.
         * @summary Update user status
         * @param {string} id User ID
         * @param {UpdateUserStatusDto} updateUserStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdateStatus(id: string, updateUserStatusDto: UpdateUserStatusDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdateStatus(id, updateUserStatusDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdateStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Creates a new address for the authenticated user
         * @summary Create address
         * @param {CreateAddressDto} createAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreateAddress(createAddressDto: CreateAddressDto, options?: RawAxiosRequestConfig): AxiosPromise<AddressResponseDto> {
            return localVarFp.userControllerCreateAddress(createAddressDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all users with pagination. Admin only.
         * @summary Get all users
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {string} [search] Search term
         * @param {UserControllerFindAllStatusEnum} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll(page?: number, limit?: number, search?: string, status?: UserControllerFindAllStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserResponseDto>> {
            return localVarFp.userControllerFindAll(page, limit, search, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single user by ID. Admin only.
         * @summary Get user by ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.userControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the authenticated user profile
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMe(options?: RawAxiosRequestConfig): AxiosPromise<UserControllerGetMe200Response> {
            return localVarFp.userControllerGetMe(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the authenticated user profile
         * @summary Update current user
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.userControllerUpdate(updateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing address for the authenticated user
         * @summary Update address
         * @param {string} id Address ID
         * @param {UpdateAddressDto} updateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateAddress(id: string, updateAddressDto: UpdateAddressDto, options?: RawAxiosRequestConfig): AxiosPromise<AddressResponseDto> {
            return localVarFp.userControllerUpdateAddress(id, updateAddressDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates user account status. Admin only.
         * @summary Update user status
         * @param {string} id User ID
         * @param {UpdateUserStatusDto} updateUserStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateStatus(id: string, updateUserStatusDto: UpdateUserStatusDto, options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.userControllerUpdateStatus(id, updateUserStatusDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * Creates a new address for the authenticated user
     * @summary Create address
     * @param {CreateAddressDto} createAddressDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerCreateAddress(createAddressDto: CreateAddressDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerCreateAddress(createAddressDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all users with pagination. Admin only.
     * @summary Get all users
     * @param {number} [page] Page number
     * @param {number} [limit] Items per page
     * @param {string} [search] Search term
     * @param {UserControllerFindAllStatusEnum} [status] Filter by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerFindAll(page?: number, limit?: number, search?: string, status?: UserControllerFindAllStatusEnum, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindAll(page, limit, search, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single user by ID. Admin only.
     * @summary Get user by ID
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the authenticated user profile
     * @summary Get current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerGetMe(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the authenticated user profile
     * @summary Update current user
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerUpdate(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdate(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing address for the authenticated user
     * @summary Update address
     * @param {string} id Address ID
     * @param {UpdateAddressDto} updateAddressDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerUpdateAddress(id: string, updateAddressDto: UpdateAddressDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdateAddress(id, updateAddressDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates user account status. Admin only.
     * @summary Update user status
     * @param {string} id User ID
     * @param {UpdateUserStatusDto} updateUserStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userControllerUpdateStatus(id: string, updateUserStatusDto: UpdateUserStatusDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdateStatus(id, updateUserStatusDto, options).then((request) => request(this.axios, this.basePath));
    }
}

export const UserControllerFindAllStatusEnum = {
    Active: 'active',
    Suspended: 'suspended',
    Disabled: 'disabled'
} as const;
export type UserControllerFindAllStatusEnum = typeof UserControllerFindAllStatusEnum[keyof typeof UserControllerFindAllStatusEnum];


